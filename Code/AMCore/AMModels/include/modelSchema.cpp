// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "modelSchema.h"

// ActivePhasesModel
// 

const ActivePhasesModel::Id_optional& ActivePhasesModel::
Id () const
{
  return this->Id_;
}

ActivePhasesModel::Id_optional& ActivePhasesModel::
Id ()
{
  return this->Id_;
}

void ActivePhasesModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void ActivePhasesModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const ActivePhasesModel::IDProject_optional& ActivePhasesModel::
IDProject () const
{
  return this->IDProject_;
}

ActivePhasesModel::IDProject_optional& ActivePhasesModel::
IDProject ()
{
  return this->IDProject_;
}

void ActivePhasesModel::
IDProject (const IDProject_type& x)
{
  this->IDProject_.set (x);
}

void ActivePhasesModel::
IDProject (const IDProject_optional& x)
{
  this->IDProject_ = x;
}

const ActivePhasesModel::IDPhase_optional& ActivePhasesModel::
IDPhase () const
{
  return this->IDPhase_;
}

ActivePhasesModel::IDPhase_optional& ActivePhasesModel::
IDPhase ()
{
  return this->IDPhase_;
}

void ActivePhasesModel::
IDPhase (const IDPhase_type& x)
{
  this->IDPhase_.set (x);
}

void ActivePhasesModel::
IDPhase (const IDPhase_optional& x)
{
  this->IDPhase_ = x;
}


// ActivePhasesConfigurationModel
// 

const ActivePhasesConfigurationModel::Id_optional& ActivePhasesConfigurationModel::
Id () const
{
  return this->Id_;
}

ActivePhasesConfigurationModel::Id_optional& ActivePhasesConfigurationModel::
Id ()
{
  return this->Id_;
}

void ActivePhasesConfigurationModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void ActivePhasesConfigurationModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const ActivePhasesConfigurationModel::IDProject_optional& ActivePhasesConfigurationModel::
IDProject () const
{
  return this->IDProject_;
}

ActivePhasesConfigurationModel::IDProject_optional& ActivePhasesConfigurationModel::
IDProject ()
{
  return this->IDProject_;
}

void ActivePhasesConfigurationModel::
IDProject (const IDProject_type& x)
{
  this->IDProject_.set (x);
}

void ActivePhasesConfigurationModel::
IDProject (const IDProject_optional& x)
{
  this->IDProject_ = x;
}

const ActivePhasesConfigurationModel::StartTemp_optional& ActivePhasesConfigurationModel::
StartTemp () const
{
  return this->StartTemp_;
}

ActivePhasesConfigurationModel::StartTemp_optional& ActivePhasesConfigurationModel::
StartTemp ()
{
  return this->StartTemp_;
}

void ActivePhasesConfigurationModel::
StartTemp (const StartTemp_type& x)
{
  this->StartTemp_.set (x);
}

void ActivePhasesConfigurationModel::
StartTemp (const StartTemp_optional& x)
{
  this->StartTemp_ = x;
}

const ActivePhasesConfigurationModel::EndTemp_optional& ActivePhasesConfigurationModel::
EndTemp () const
{
  return this->EndTemp_;
}

ActivePhasesConfigurationModel::EndTemp_optional& ActivePhasesConfigurationModel::
EndTemp ()
{
  return this->EndTemp_;
}

void ActivePhasesConfigurationModel::
EndTemp (const EndTemp_type& x)
{
  this->EndTemp_.set (x);
}

void ActivePhasesConfigurationModel::
EndTemp (const EndTemp_optional& x)
{
  this->EndTemp_ = x;
}

const ActivePhasesConfigurationModel::StepSize_optional& ActivePhasesConfigurationModel::
StepSize () const
{
  return this->StepSize_;
}

ActivePhasesConfigurationModel::StepSize_optional& ActivePhasesConfigurationModel::
StepSize ()
{
  return this->StepSize_;
}

void ActivePhasesConfigurationModel::
StepSize (const StepSize_type& x)
{
  this->StepSize_.set (x);
}

void ActivePhasesConfigurationModel::
StepSize (const StepSize_optional& x)
{
  this->StepSize_ = x;
}


// ActivePhasesElementCompositionModel
// 

const ActivePhasesElementCompositionModel::Id_optional& ActivePhasesElementCompositionModel::
Id () const
{
  return this->Id_;
}

ActivePhasesElementCompositionModel::Id_optional& ActivePhasesElementCompositionModel::
Id ()
{
  return this->Id_;
}

void ActivePhasesElementCompositionModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void ActivePhasesElementCompositionModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const ActivePhasesElementCompositionModel::IDProject_optional& ActivePhasesElementCompositionModel::
IDProject () const
{
  return this->IDProject_;
}

ActivePhasesElementCompositionModel::IDProject_optional& ActivePhasesElementCompositionModel::
IDProject ()
{
  return this->IDProject_;
}

void ActivePhasesElementCompositionModel::
IDProject (const IDProject_type& x)
{
  this->IDProject_.set (x);
}

void ActivePhasesElementCompositionModel::
IDProject (const IDProject_optional& x)
{
  this->IDProject_ = x;
}

const ActivePhasesElementCompositionModel::IDElement_optional& ActivePhasesElementCompositionModel::
IDElement () const
{
  return this->IDElement_;
}

ActivePhasesElementCompositionModel::IDElement_optional& ActivePhasesElementCompositionModel::
IDElement ()
{
  return this->IDElement_;
}

void ActivePhasesElementCompositionModel::
IDElement (const IDElement_type& x)
{
  this->IDElement_.set (x);
}

void ActivePhasesElementCompositionModel::
IDElement (const IDElement_optional& x)
{
  this->IDElement_ = x;
}

const ActivePhasesElementCompositionModel::Value_optional& ActivePhasesElementCompositionModel::
Value () const
{
  return this->Value_;
}

ActivePhasesElementCompositionModel::Value_optional& ActivePhasesElementCompositionModel::
Value ()
{
  return this->Value_;
}

void ActivePhasesElementCompositionModel::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ActivePhasesElementCompositionModel::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// CALPHADDatabaseModel
// 

const CALPHADDatabaseModel::Id_optional& CALPHADDatabaseModel::
Id () const
{
  return this->Id_;
}

CALPHADDatabaseModel::Id_optional& CALPHADDatabaseModel::
Id ()
{
  return this->Id_;
}

void CALPHADDatabaseModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void CALPHADDatabaseModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const CALPHADDatabaseModel::IDProject_optional& CALPHADDatabaseModel::
IDProject () const
{
  return this->IDProject_;
}

CALPHADDatabaseModel::IDProject_optional& CALPHADDatabaseModel::
IDProject ()
{
  return this->IDProject_;
}

void CALPHADDatabaseModel::
IDProject (const IDProject_type& x)
{
  this->IDProject_.set (x);
}

void CALPHADDatabaseModel::
IDProject (const IDProject_optional& x)
{
  this->IDProject_ = x;
}

const CALPHADDatabaseModel::Thermodynamic_optional& CALPHADDatabaseModel::
Thermodynamic () const
{
  return this->Thermodynamic_;
}

CALPHADDatabaseModel::Thermodynamic_optional& CALPHADDatabaseModel::
Thermodynamic ()
{
  return this->Thermodynamic_;
}

void CALPHADDatabaseModel::
Thermodynamic (const Thermodynamic_type& x)
{
  this->Thermodynamic_.set (x);
}

void CALPHADDatabaseModel::
Thermodynamic (const Thermodynamic_optional& x)
{
  this->Thermodynamic_ = x;
}

void CALPHADDatabaseModel::
Thermodynamic (::std::unique_ptr< Thermodynamic_type > x)
{
  this->Thermodynamic_.set (std::move (x));
}

const CALPHADDatabaseModel::Physical_optional& CALPHADDatabaseModel::
Physical () const
{
  return this->Physical_;
}

CALPHADDatabaseModel::Physical_optional& CALPHADDatabaseModel::
Physical ()
{
  return this->Physical_;
}

void CALPHADDatabaseModel::
Physical (const Physical_type& x)
{
  this->Physical_.set (x);
}

void CALPHADDatabaseModel::
Physical (const Physical_optional& x)
{
  this->Physical_ = x;
}

void CALPHADDatabaseModel::
Physical (::std::unique_ptr< Physical_type > x)
{
  this->Physical_.set (std::move (x));
}

const CALPHADDatabaseModel::Mobility_optional& CALPHADDatabaseModel::
Mobility () const
{
  return this->Mobility_;
}

CALPHADDatabaseModel::Mobility_optional& CALPHADDatabaseModel::
Mobility ()
{
  return this->Mobility_;
}

void CALPHADDatabaseModel::
Mobility (const Mobility_type& x)
{
  this->Mobility_.set (x);
}

void CALPHADDatabaseModel::
Mobility (const Mobility_optional& x)
{
  this->Mobility_ = x;
}

void CALPHADDatabaseModel::
Mobility (::std::unique_ptr< Mobility_type > x)
{
  this->Mobility_.set (std::move (x));
}


// CaseModel
// 

const CaseModel::Id_optional& CaseModel::
Id () const
{
  return this->Id_;
}

CaseModel::Id_optional& CaseModel::
Id ()
{
  return this->Id_;
}

void CaseModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void CaseModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const CaseModel::IDProject_optional& CaseModel::
IDProject () const
{
  return this->IDProject_;
}

CaseModel::IDProject_optional& CaseModel::
IDProject ()
{
  return this->IDProject_;
}

void CaseModel::
IDProject (const IDProject_type& x)
{
  this->IDProject_.set (x);
}

void CaseModel::
IDProject (const IDProject_optional& x)
{
  this->IDProject_ = x;
}

const CaseModel::IDGroup_optional& CaseModel::
IDGroup () const
{
  return this->IDGroup_;
}

CaseModel::IDGroup_optional& CaseModel::
IDGroup ()
{
  return this->IDGroup_;
}

void CaseModel::
IDGroup (const IDGroup_type& x)
{
  this->IDGroup_.set (x);
}

void CaseModel::
IDGroup (const IDGroup_optional& x)
{
  this->IDGroup_ = x;
}

const CaseModel::Name_optional& CaseModel::
Name () const
{
  return this->Name_;
}

CaseModel::Name_optional& CaseModel::
Name ()
{
  return this->Name_;
}

void CaseModel::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void CaseModel::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void CaseModel::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const CaseModel::Script_optional& CaseModel::
Script () const
{
  return this->Script_;
}

CaseModel::Script_optional& CaseModel::
Script ()
{
  return this->Script_;
}

void CaseModel::
Script (const Script_type& x)
{
  this->Script_.set (x);
}

void CaseModel::
Script (const Script_optional& x)
{
  this->Script_ = x;
}

void CaseModel::
Script (::std::unique_ptr< Script_type > x)
{
  this->Script_.set (std::move (x));
}

const CaseModel::Date_optional& CaseModel::
Date () const
{
  return this->Date_;
}

CaseModel::Date_optional& CaseModel::
Date ()
{
  return this->Date_;
}

void CaseModel::
Date (const Date_type& x)
{
  this->Date_.set (x);
}

void CaseModel::
Date (const Date_optional& x)
{
  this->Date_ = x;
}

void CaseModel::
Date (::std::unique_ptr< Date_type > x)
{
  this->Date_.set (std::move (x));
}

const CaseModel::PosX_optional& CaseModel::
PosX () const
{
  return this->PosX_;
}

CaseModel::PosX_optional& CaseModel::
PosX ()
{
  return this->PosX_;
}

void CaseModel::
PosX (const PosX_type& x)
{
  this->PosX_.set (x);
}

void CaseModel::
PosX (const PosX_optional& x)
{
  this->PosX_ = x;
}

const CaseModel::PosY_optional& CaseModel::
PosY () const
{
  return this->PosY_;
}

CaseModel::PosY_optional& CaseModel::
PosY ()
{
  return this->PosY_;
}

void CaseModel::
PosY (const PosY_type& x)
{
  this->PosY_.set (x);
}

void CaseModel::
PosY (const PosY_optional& x)
{
  this->PosY_ = x;
}

const CaseModel::PosZ_optional& CaseModel::
PosZ () const
{
  return this->PosZ_;
}

CaseModel::PosZ_optional& CaseModel::
PosZ ()
{
  return this->PosZ_;
}

void CaseModel::
PosZ (const PosZ_type& x)
{
  this->PosZ_.set (x);
}

void CaseModel::
PosZ (const PosZ_optional& x)
{
  this->PosZ_ = x;
}


// ElementModel
// 

const ElementModel::Id_optional& ElementModel::
Id () const
{
  return this->Id_;
}

ElementModel::Id_optional& ElementModel::
Id ()
{
  return this->Id_;
}

void ElementModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void ElementModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const ElementModel::Name_optional& ElementModel::
Name () const
{
  return this->Name_;
}

ElementModel::Name_optional& ElementModel::
Name ()
{
  return this->Name_;
}

void ElementModel::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void ElementModel::
Name (const Name_optional& x)
{
  this->Name_ = x;
}


// ElementCompositionModel
// 

const ElementCompositionModel::Id_optional& ElementCompositionModel::
Id () const
{
  return this->Id_;
}

ElementCompositionModel::Id_optional& ElementCompositionModel::
Id ()
{
  return this->Id_;
}

void ElementCompositionModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void ElementCompositionModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const ElementCompositionModel::IDCase_optional& ElementCompositionModel::
IDCase () const
{
  return this->IDCase_;
}

ElementCompositionModel::IDCase_optional& ElementCompositionModel::
IDCase ()
{
  return this->IDCase_;
}

void ElementCompositionModel::
IDCase (const IDCase_type& x)
{
  this->IDCase_.set (x);
}

void ElementCompositionModel::
IDCase (const IDCase_optional& x)
{
  this->IDCase_ = x;
}

const ElementCompositionModel::IDElement_optional& ElementCompositionModel::
IDElement () const
{
  return this->IDElement_;
}

ElementCompositionModel::IDElement_optional& ElementCompositionModel::
IDElement ()
{
  return this->IDElement_;
}

void ElementCompositionModel::
IDElement (const IDElement_type& x)
{
  this->IDElement_.set (x);
}

void ElementCompositionModel::
IDElement (const IDElement_optional& x)
{
  this->IDElement_ = x;
}

const ElementCompositionModel::TypeComposition_optional& ElementCompositionModel::
TypeComposition () const
{
  return this->TypeComposition_;
}

ElementCompositionModel::TypeComposition_optional& ElementCompositionModel::
TypeComposition ()
{
  return this->TypeComposition_;
}

void ElementCompositionModel::
TypeComposition (const TypeComposition_type& x)
{
  this->TypeComposition_.set (x);
}

void ElementCompositionModel::
TypeComposition (const TypeComposition_optional& x)
{
  this->TypeComposition_ = x;
}

void ElementCompositionModel::
TypeComposition (::std::unique_ptr< TypeComposition_type > x)
{
  this->TypeComposition_.set (std::move (x));
}

const ElementCompositionModel::Value_optional& ElementCompositionModel::
Value () const
{
  return this->Value_;
}

ElementCompositionModel::Value_optional& ElementCompositionModel::
Value ()
{
  return this->Value_;
}

void ElementCompositionModel::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ElementCompositionModel::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// EquilibriumConfigurationModel
// 

const EquilibriumConfigurationModel::Id_optional& EquilibriumConfigurationModel::
Id () const
{
  return this->Id_;
}

EquilibriumConfigurationModel::Id_optional& EquilibriumConfigurationModel::
Id ()
{
  return this->Id_;
}

void EquilibriumConfigurationModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void EquilibriumConfigurationModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const EquilibriumConfigurationModel::IDCase_optional& EquilibriumConfigurationModel::
IDCase () const
{
  return this->IDCase_;
}

EquilibriumConfigurationModel::IDCase_optional& EquilibriumConfigurationModel::
IDCase ()
{
  return this->IDCase_;
}

void EquilibriumConfigurationModel::
IDCase (const IDCase_type& x)
{
  this->IDCase_.set (x);
}

void EquilibriumConfigurationModel::
IDCase (const IDCase_optional& x)
{
  this->IDCase_ = x;
}

const EquilibriumConfigurationModel::Temperature_optional& EquilibriumConfigurationModel::
Temperature () const
{
  return this->Temperature_;
}

EquilibriumConfigurationModel::Temperature_optional& EquilibriumConfigurationModel::
Temperature ()
{
  return this->Temperature_;
}

void EquilibriumConfigurationModel::
Temperature (const Temperature_type& x)
{
  this->Temperature_.set (x);
}

void EquilibriumConfigurationModel::
Temperature (const Temperature_optional& x)
{
  this->Temperature_ = x;
}

const EquilibriumConfigurationModel::StartTemperature_optional& EquilibriumConfigurationModel::
StartTemperature () const
{
  return this->StartTemperature_;
}

EquilibriumConfigurationModel::StartTemperature_optional& EquilibriumConfigurationModel::
StartTemperature ()
{
  return this->StartTemperature_;
}

void EquilibriumConfigurationModel::
StartTemperature (const StartTemperature_type& x)
{
  this->StartTemperature_.set (x);
}

void EquilibriumConfigurationModel::
StartTemperature (const StartTemperature_optional& x)
{
  this->StartTemperature_ = x;
}

const EquilibriumConfigurationModel::EndTemperature_optional& EquilibriumConfigurationModel::
EndTemperature () const
{
  return this->EndTemperature_;
}

EquilibriumConfigurationModel::EndTemperature_optional& EquilibriumConfigurationModel::
EndTemperature ()
{
  return this->EndTemperature_;
}

void EquilibriumConfigurationModel::
EndTemperature (const EndTemperature_type& x)
{
  this->EndTemperature_.set (x);
}

void EquilibriumConfigurationModel::
EndTemperature (const EndTemperature_optional& x)
{
  this->EndTemperature_ = x;
}

const EquilibriumConfigurationModel::TemperatureType_optional& EquilibriumConfigurationModel::
TemperatureType () const
{
  return this->TemperatureType_;
}

EquilibriumConfigurationModel::TemperatureType_optional& EquilibriumConfigurationModel::
TemperatureType ()
{
  return this->TemperatureType_;
}

void EquilibriumConfigurationModel::
TemperatureType (const TemperatureType_type& x)
{
  this->TemperatureType_.set (x);
}

void EquilibriumConfigurationModel::
TemperatureType (const TemperatureType_optional& x)
{
  this->TemperatureType_ = x;
}

void EquilibriumConfigurationModel::
TemperatureType (::std::unique_ptr< TemperatureType_type > x)
{
  this->TemperatureType_.set (std::move (x));
}

const EquilibriumConfigurationModel::StepSize_optional& EquilibriumConfigurationModel::
StepSize () const
{
  return this->StepSize_;
}

EquilibriumConfigurationModel::StepSize_optional& EquilibriumConfigurationModel::
StepSize ()
{
  return this->StepSize_;
}

void EquilibriumConfigurationModel::
StepSize (const StepSize_type& x)
{
  this->StepSize_.set (x);
}

void EquilibriumConfigurationModel::
StepSize (const StepSize_optional& x)
{
  this->StepSize_ = x;
}

const EquilibriumConfigurationModel::Pressure_optional& EquilibriumConfigurationModel::
Pressure () const
{
  return this->Pressure_;
}

EquilibriumConfigurationModel::Pressure_optional& EquilibriumConfigurationModel::
Pressure ()
{
  return this->Pressure_;
}

void EquilibriumConfigurationModel::
Pressure (const Pressure_type& x)
{
  this->Pressure_.set (x);
}

void EquilibriumConfigurationModel::
Pressure (const Pressure_optional& x)
{
  this->Pressure_ = x;
}


// EquilibriumPhaseFractionModel
// 

const EquilibriumPhaseFractionModel::Id_optional& EquilibriumPhaseFractionModel::
Id () const
{
  return this->Id_;
}

EquilibriumPhaseFractionModel::Id_optional& EquilibriumPhaseFractionModel::
Id ()
{
  return this->Id_;
}

void EquilibriumPhaseFractionModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void EquilibriumPhaseFractionModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const EquilibriumPhaseFractionModel::IDCase_optional& EquilibriumPhaseFractionModel::
IDCase () const
{
  return this->IDCase_;
}

EquilibriumPhaseFractionModel::IDCase_optional& EquilibriumPhaseFractionModel::
IDCase ()
{
  return this->IDCase_;
}

void EquilibriumPhaseFractionModel::
IDCase (const IDCase_type& x)
{
  this->IDCase_.set (x);
}

void EquilibriumPhaseFractionModel::
IDCase (const IDCase_optional& x)
{
  this->IDCase_ = x;
}

const EquilibriumPhaseFractionModel::Temperature_optional& EquilibriumPhaseFractionModel::
Temperature () const
{
  return this->Temperature_;
}

EquilibriumPhaseFractionModel::Temperature_optional& EquilibriumPhaseFractionModel::
Temperature ()
{
  return this->Temperature_;
}

void EquilibriumPhaseFractionModel::
Temperature (const Temperature_type& x)
{
  this->Temperature_.set (x);
}

void EquilibriumPhaseFractionModel::
Temperature (const Temperature_optional& x)
{
  this->Temperature_ = x;
}

const EquilibriumPhaseFractionModel::Value_optional& EquilibriumPhaseFractionModel::
Value () const
{
  return this->Value_;
}

EquilibriumPhaseFractionModel::Value_optional& EquilibriumPhaseFractionModel::
Value ()
{
  return this->Value_;
}

void EquilibriumPhaseFractionModel::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void EquilibriumPhaseFractionModel::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// HeatTreatmentModel
// 

const HeatTreatmentModel::Id_optional& HeatTreatmentModel::
Id () const
{
  return this->Id_;
}

HeatTreatmentModel::Id_optional& HeatTreatmentModel::
Id ()
{
  return this->Id_;
}

void HeatTreatmentModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void HeatTreatmentModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const HeatTreatmentModel::IDCase_optional& HeatTreatmentModel::
IDCase () const
{
  return this->IDCase_;
}

HeatTreatmentModel::IDCase_optional& HeatTreatmentModel::
IDCase ()
{
  return this->IDCase_;
}

void HeatTreatmentModel::
IDCase (const IDCase_type& x)
{
  this->IDCase_.set (x);
}

void HeatTreatmentModel::
IDCase (const IDCase_optional& x)
{
  this->IDCase_ = x;
}

const HeatTreatmentModel::Name_optional& HeatTreatmentModel::
Name () const
{
  return this->Name_;
}

HeatTreatmentModel::Name_optional& HeatTreatmentModel::
Name ()
{
  return this->Name_;
}

void HeatTreatmentModel::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void HeatTreatmentModel::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

const HeatTreatmentModel::MaxTemperatureStep_optional& HeatTreatmentModel::
MaxTemperatureStep () const
{
  return this->MaxTemperatureStep_;
}

HeatTreatmentModel::MaxTemperatureStep_optional& HeatTreatmentModel::
MaxTemperatureStep ()
{
  return this->MaxTemperatureStep_;
}

void HeatTreatmentModel::
MaxTemperatureStep (const MaxTemperatureStep_type& x)
{
  this->MaxTemperatureStep_.set (x);
}

void HeatTreatmentModel::
MaxTemperatureStep (const MaxTemperatureStep_optional& x)
{
  this->MaxTemperatureStep_ = x;
}

const HeatTreatmentModel::IDPrecipitationDomain_optional& HeatTreatmentModel::
IDPrecipitationDomain () const
{
  return this->IDPrecipitationDomain_;
}

HeatTreatmentModel::IDPrecipitationDomain_optional& HeatTreatmentModel::
IDPrecipitationDomain ()
{
  return this->IDPrecipitationDomain_;
}

void HeatTreatmentModel::
IDPrecipitationDomain (const IDPrecipitationDomain_type& x)
{
  this->IDPrecipitationDomain_.set (x);
}

void HeatTreatmentModel::
IDPrecipitationDomain (const IDPrecipitationDomain_optional& x)
{
  this->IDPrecipitationDomain_ = x;
}

const HeatTreatmentModel::StartTemperature_optional& HeatTreatmentModel::
StartTemperature () const
{
  return this->StartTemperature_;
}

HeatTreatmentModel::StartTemperature_optional& HeatTreatmentModel::
StartTemperature ()
{
  return this->StartTemperature_;
}

void HeatTreatmentModel::
StartTemperature (const StartTemperature_type& x)
{
  this->StartTemperature_.set (x);
}

void HeatTreatmentModel::
StartTemperature (const StartTemperature_optional& x)
{
  this->StartTemperature_ = x;
}


// HeatTreatmentProfileModel
// 

const HeatTreatmentProfileModel::Id_optional& HeatTreatmentProfileModel::
Id () const
{
  return this->Id_;
}

HeatTreatmentProfileModel::Id_optional& HeatTreatmentProfileModel::
Id ()
{
  return this->Id_;
}

void HeatTreatmentProfileModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void HeatTreatmentProfileModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const HeatTreatmentProfileModel::IDHeatTreatment_optional& HeatTreatmentProfileModel::
IDHeatTreatment () const
{
  return this->IDHeatTreatment_;
}

HeatTreatmentProfileModel::IDHeatTreatment_optional& HeatTreatmentProfileModel::
IDHeatTreatment ()
{
  return this->IDHeatTreatment_;
}

void HeatTreatmentProfileModel::
IDHeatTreatment (const IDHeatTreatment_type& x)
{
  this->IDHeatTreatment_.set (x);
}

void HeatTreatmentProfileModel::
IDHeatTreatment (const IDHeatTreatment_optional& x)
{
  this->IDHeatTreatment_ = x;
}

const HeatTreatmentProfileModel::Time_optional& HeatTreatmentProfileModel::
Time () const
{
  return this->Time_;
}

HeatTreatmentProfileModel::Time_optional& HeatTreatmentProfileModel::
Time ()
{
  return this->Time_;
}

void HeatTreatmentProfileModel::
Time (const Time_type& x)
{
  this->Time_.set (x);
}

void HeatTreatmentProfileModel::
Time (const Time_optional& x)
{
  this->Time_ = x;
}

const HeatTreatmentProfileModel::Temperature_optional& HeatTreatmentProfileModel::
Temperature () const
{
  return this->Temperature_;
}

HeatTreatmentProfileModel::Temperature_optional& HeatTreatmentProfileModel::
Temperature ()
{
  return this->Temperature_;
}

void HeatTreatmentProfileModel::
Temperature (const Temperature_type& x)
{
  this->Temperature_.set (x);
}

void HeatTreatmentProfileModel::
Temperature (const Temperature_optional& x)
{
  this->Temperature_ = x;
}


// HeatTreatmentSegmentModel
// 

const HeatTreatmentSegmentModel::Id_optional& HeatTreatmentSegmentModel::
Id () const
{
  return this->Id_;
}

HeatTreatmentSegmentModel::Id_optional& HeatTreatmentSegmentModel::
Id ()
{
  return this->Id_;
}

void HeatTreatmentSegmentModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void HeatTreatmentSegmentModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const HeatTreatmentSegmentModel::StepIndex_optional& HeatTreatmentSegmentModel::
StepIndex () const
{
  return this->StepIndex_;
}

HeatTreatmentSegmentModel::StepIndex_optional& HeatTreatmentSegmentModel::
StepIndex ()
{
  return this->StepIndex_;
}

void HeatTreatmentSegmentModel::
StepIndex (const StepIndex_type& x)
{
  this->StepIndex_.set (x);
}

void HeatTreatmentSegmentModel::
StepIndex (const StepIndex_optional& x)
{
  this->StepIndex_ = x;
}

const HeatTreatmentSegmentModel::IDHeatTreatment_optional& HeatTreatmentSegmentModel::
IDHeatTreatment () const
{
  return this->IDHeatTreatment_;
}

HeatTreatmentSegmentModel::IDHeatTreatment_optional& HeatTreatmentSegmentModel::
IDHeatTreatment ()
{
  return this->IDHeatTreatment_;
}

void HeatTreatmentSegmentModel::
IDHeatTreatment (const IDHeatTreatment_type& x)
{
  this->IDHeatTreatment_.set (x);
}

void HeatTreatmentSegmentModel::
IDHeatTreatment (const IDHeatTreatment_optional& x)
{
  this->IDHeatTreatment_ = x;
}

const HeatTreatmentSegmentModel::IDPrecipitationDomain_optional& HeatTreatmentSegmentModel::
IDPrecipitationDomain () const
{
  return this->IDPrecipitationDomain_;
}

HeatTreatmentSegmentModel::IDPrecipitationDomain_optional& HeatTreatmentSegmentModel::
IDPrecipitationDomain ()
{
  return this->IDPrecipitationDomain_;
}

void HeatTreatmentSegmentModel::
IDPrecipitationDomain (const IDPrecipitationDomain_type& x)
{
  this->IDPrecipitationDomain_.set (x);
}

void HeatTreatmentSegmentModel::
IDPrecipitationDomain (const IDPrecipitationDomain_optional& x)
{
  this->IDPrecipitationDomain_ = x;
}

const HeatTreatmentSegmentModel::EndTemperature_optional& HeatTreatmentSegmentModel::
EndTemperature () const
{
  return this->EndTemperature_;
}

HeatTreatmentSegmentModel::EndTemperature_optional& HeatTreatmentSegmentModel::
EndTemperature ()
{
  return this->EndTemperature_;
}

void HeatTreatmentSegmentModel::
EndTemperature (const EndTemperature_type& x)
{
  this->EndTemperature_.set (x);
}

void HeatTreatmentSegmentModel::
EndTemperature (const EndTemperature_optional& x)
{
  this->EndTemperature_ = x;
}

const HeatTreatmentSegmentModel::TemperatureGradient_optional& HeatTreatmentSegmentModel::
TemperatureGradient () const
{
  return this->TemperatureGradient_;
}

HeatTreatmentSegmentModel::TemperatureGradient_optional& HeatTreatmentSegmentModel::
TemperatureGradient ()
{
  return this->TemperatureGradient_;
}

void HeatTreatmentSegmentModel::
TemperatureGradient (const TemperatureGradient_type& x)
{
  this->TemperatureGradient_.set (x);
}

void HeatTreatmentSegmentModel::
TemperatureGradient (const TemperatureGradient_optional& x)
{
  this->TemperatureGradient_ = x;
}

const HeatTreatmentSegmentModel::Duration_optional& HeatTreatmentSegmentModel::
Duration () const
{
  return this->Duration_;
}

HeatTreatmentSegmentModel::Duration_optional& HeatTreatmentSegmentModel::
Duration ()
{
  return this->Duration_;
}

void HeatTreatmentSegmentModel::
Duration (const Duration_type& x)
{
  this->Duration_.set (x);
}

void HeatTreatmentSegmentModel::
Duration (const Duration_optional& x)
{
  this->Duration_ = x;
}


// PhaseModel
// 

const PhaseModel::Id_optional& PhaseModel::
Id () const
{
  return this->Id_;
}

PhaseModel::Id_optional& PhaseModel::
Id ()
{
  return this->Id_;
}

void PhaseModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void PhaseModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const PhaseModel::Name_optional& PhaseModel::
Name () const
{
  return this->Name_;
}

PhaseModel::Name_optional& PhaseModel::
Name ()
{
  return this->Name_;
}

void PhaseModel::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void PhaseModel::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void PhaseModel::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const PhaseModel::DBType_optional& PhaseModel::
DBType () const
{
  return this->DBType_;
}

PhaseModel::DBType_optional& PhaseModel::
DBType ()
{
  return this->DBType_;
}

void PhaseModel::
DBType (const DBType_type& x)
{
  this->DBType_.set (x);
}

void PhaseModel::
DBType (const DBType_optional& x)
{
  this->DBType_ = x;
}


// PrecipitationSimulationDataModel
// 

const PrecipitationSimulationDataModel::Id_optional& PrecipitationSimulationDataModel::
Id () const
{
  return this->Id_;
}

PrecipitationSimulationDataModel::Id_optional& PrecipitationSimulationDataModel::
Id ()
{
  return this->Id_;
}

void PrecipitationSimulationDataModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void PrecipitationSimulationDataModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const PrecipitationSimulationDataModel::IDPrecipitationPhase_optional& PrecipitationSimulationDataModel::
IDPrecipitationPhase () const
{
  return this->IDPrecipitationPhase_;
}

PrecipitationSimulationDataModel::IDPrecipitationPhase_optional& PrecipitationSimulationDataModel::
IDPrecipitationPhase ()
{
  return this->IDPrecipitationPhase_;
}

void PrecipitationSimulationDataModel::
IDPrecipitationPhase (const IDPrecipitationPhase_type& x)
{
  this->IDPrecipitationPhase_.set (x);
}

void PrecipitationSimulationDataModel::
IDPrecipitationPhase (const IDPrecipitationPhase_optional& x)
{
  this->IDPrecipitationPhase_ = x;
}

const PrecipitationSimulationDataModel::IDHeatTreatment_optional& PrecipitationSimulationDataModel::
IDHeatTreatment () const
{
  return this->IDHeatTreatment_;
}

PrecipitationSimulationDataModel::IDHeatTreatment_optional& PrecipitationSimulationDataModel::
IDHeatTreatment ()
{
  return this->IDHeatTreatment_;
}

void PrecipitationSimulationDataModel::
IDHeatTreatment (const IDHeatTreatment_type& x)
{
  this->IDHeatTreatment_.set (x);
}

void PrecipitationSimulationDataModel::
IDHeatTreatment (const IDHeatTreatment_optional& x)
{
  this->IDHeatTreatment_ = x;
}

const PrecipitationSimulationDataModel::Time_optional& PrecipitationSimulationDataModel::
Time () const
{
  return this->Time_;
}

PrecipitationSimulationDataModel::Time_optional& PrecipitationSimulationDataModel::
Time ()
{
  return this->Time_;
}

void PrecipitationSimulationDataModel::
Time (const Time_type& x)
{
  this->Time_.set (x);
}

void PrecipitationSimulationDataModel::
Time (const Time_optional& x)
{
  this->Time_ = x;
}

const PrecipitationSimulationDataModel::PhaseFraction_optional& PrecipitationSimulationDataModel::
PhaseFraction () const
{
  return this->PhaseFraction_;
}

PrecipitationSimulationDataModel::PhaseFraction_optional& PrecipitationSimulationDataModel::
PhaseFraction ()
{
  return this->PhaseFraction_;
}

void PrecipitationSimulationDataModel::
PhaseFraction (const PhaseFraction_type& x)
{
  this->PhaseFraction_.set (x);
}

void PrecipitationSimulationDataModel::
PhaseFraction (const PhaseFraction_optional& x)
{
  this->PhaseFraction_ = x;
}

const PrecipitationSimulationDataModel::NumberDensity_optional& PrecipitationSimulationDataModel::
NumberDensity () const
{
  return this->NumberDensity_;
}

PrecipitationSimulationDataModel::NumberDensity_optional& PrecipitationSimulationDataModel::
NumberDensity ()
{
  return this->NumberDensity_;
}

void PrecipitationSimulationDataModel::
NumberDensity (const NumberDensity_type& x)
{
  this->NumberDensity_.set (x);
}

void PrecipitationSimulationDataModel::
NumberDensity (const NumberDensity_optional& x)
{
  this->NumberDensity_ = x;
}

const PrecipitationSimulationDataModel::MeanRadius_optional& PrecipitationSimulationDataModel::
MeanRadius () const
{
  return this->MeanRadius_;
}

PrecipitationSimulationDataModel::MeanRadius_optional& PrecipitationSimulationDataModel::
MeanRadius ()
{
  return this->MeanRadius_;
}

void PrecipitationSimulationDataModel::
MeanRadius (const MeanRadius_type& x)
{
  this->MeanRadius_.set (x);
}

void PrecipitationSimulationDataModel::
MeanRadius (const MeanRadius_optional& x)
{
  this->MeanRadius_ = x;
}


// PrecipitationDomainModel
// 

const PrecipitationDomainModel::Id_optional& PrecipitationDomainModel::
Id () const
{
  return this->Id_;
}

PrecipitationDomainModel::Id_optional& PrecipitationDomainModel::
Id ()
{
  return this->Id_;
}

void PrecipitationDomainModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void PrecipitationDomainModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const PrecipitationDomainModel::IDCase_optional& PrecipitationDomainModel::
IDCase () const
{
  return this->IDCase_;
}

PrecipitationDomainModel::IDCase_optional& PrecipitationDomainModel::
IDCase ()
{
  return this->IDCase_;
}

void PrecipitationDomainModel::
IDCase (const IDCase_type& x)
{
  this->IDCase_.set (x);
}

void PrecipitationDomainModel::
IDCase (const IDCase_optional& x)
{
  this->IDCase_ = x;
}

const PrecipitationDomainModel::Name_optional& PrecipitationDomainModel::
Name () const
{
  return this->Name_;
}

PrecipitationDomainModel::Name_optional& PrecipitationDomainModel::
Name ()
{
  return this->Name_;
}

void PrecipitationDomainModel::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void PrecipitationDomainModel::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void PrecipitationDomainModel::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const PrecipitationDomainModel::IDPhase_optional& PrecipitationDomainModel::
IDPhase () const
{
  return this->IDPhase_;
}

PrecipitationDomainModel::IDPhase_optional& PrecipitationDomainModel::
IDPhase ()
{
  return this->IDPhase_;
}

void PrecipitationDomainModel::
IDPhase (const IDPhase_type& x)
{
  this->IDPhase_.set (x);
}

void PrecipitationDomainModel::
IDPhase (const IDPhase_optional& x)
{
  this->IDPhase_ = x;
}

const PrecipitationDomainModel::InitialGrainDiameter_optional& PrecipitationDomainModel::
InitialGrainDiameter () const
{
  return this->InitialGrainDiameter_;
}

PrecipitationDomainModel::InitialGrainDiameter_optional& PrecipitationDomainModel::
InitialGrainDiameter ()
{
  return this->InitialGrainDiameter_;
}

void PrecipitationDomainModel::
InitialGrainDiameter (const InitialGrainDiameter_type& x)
{
  this->InitialGrainDiameter_.set (x);
}

void PrecipitationDomainModel::
InitialGrainDiameter (const InitialGrainDiameter_optional& x)
{
  this->InitialGrainDiameter_ = x;
}

const PrecipitationDomainModel::EquilibriumDiDe_optional& PrecipitationDomainModel::
EquilibriumDiDe () const
{
  return this->EquilibriumDiDe_;
}

PrecipitationDomainModel::EquilibriumDiDe_optional& PrecipitationDomainModel::
EquilibriumDiDe ()
{
  return this->EquilibriumDiDe_;
}

void PrecipitationDomainModel::
EquilibriumDiDe (const EquilibriumDiDe_type& x)
{
  this->EquilibriumDiDe_.set (x);
}

void PrecipitationDomainModel::
EquilibriumDiDe (const EquilibriumDiDe_optional& x)
{
  this->EquilibriumDiDe_ = x;
}


// PrecipitationPhaseModel
// 

const PrecipitationPhaseModel::Id_optional& PrecipitationPhaseModel::
Id () const
{
  return this->Id_;
}

PrecipitationPhaseModel::Id_optional& PrecipitationPhaseModel::
Id ()
{
  return this->Id_;
}

void PrecipitationPhaseModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void PrecipitationPhaseModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const PrecipitationPhaseModel::IDCase_optional& PrecipitationPhaseModel::
IDCase () const
{
  return this->IDCase_;
}

PrecipitationPhaseModel::IDCase_optional& PrecipitationPhaseModel::
IDCase ()
{
  return this->IDCase_;
}

void PrecipitationPhaseModel::
IDCase (const IDCase_type& x)
{
  this->IDCase_.set (x);
}

void PrecipitationPhaseModel::
IDCase (const IDCase_optional& x)
{
  this->IDCase_ = x;
}

const PrecipitationPhaseModel::IDPhase_optional& PrecipitationPhaseModel::
IDPhase () const
{
  return this->IDPhase_;
}

PrecipitationPhaseModel::IDPhase_optional& PrecipitationPhaseModel::
IDPhase ()
{
  return this->IDPhase_;
}

void PrecipitationPhaseModel::
IDPhase (const IDPhase_type& x)
{
  this->IDPhase_.set (x);
}

void PrecipitationPhaseModel::
IDPhase (const IDPhase_optional& x)
{
  this->IDPhase_ = x;
}

const PrecipitationPhaseModel::NumberSizeClasses_optional& PrecipitationPhaseModel::
NumberSizeClasses () const
{
  return this->NumberSizeClasses_;
}

PrecipitationPhaseModel::NumberSizeClasses_optional& PrecipitationPhaseModel::
NumberSizeClasses ()
{
  return this->NumberSizeClasses_;
}

void PrecipitationPhaseModel::
NumberSizeClasses (const NumberSizeClasses_type& x)
{
  this->NumberSizeClasses_.set (x);
}

void PrecipitationPhaseModel::
NumberSizeClasses (const NumberSizeClasses_optional& x)
{
  this->NumberSizeClasses_ = x;
}

const PrecipitationPhaseModel::Name_optional& PrecipitationPhaseModel::
Name () const
{
  return this->Name_;
}

PrecipitationPhaseModel::Name_optional& PrecipitationPhaseModel::
Name ()
{
  return this->Name_;
}

void PrecipitationPhaseModel::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void PrecipitationPhaseModel::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void PrecipitationPhaseModel::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const PrecipitationPhaseModel::NucleationSites_optional& PrecipitationPhaseModel::
NucleationSites () const
{
  return this->NucleationSites_;
}

PrecipitationPhaseModel::NucleationSites_optional& PrecipitationPhaseModel::
NucleationSites ()
{
  return this->NucleationSites_;
}

void PrecipitationPhaseModel::
NucleationSites (const NucleationSites_type& x)
{
  this->NucleationSites_.set (x);
}

void PrecipitationPhaseModel::
NucleationSites (const NucleationSites_optional& x)
{
  this->NucleationSites_ = x;
}

void PrecipitationPhaseModel::
NucleationSites (::std::unique_ptr< NucleationSites_type > x)
{
  this->NucleationSites_.set (std::move (x));
}

const PrecipitationPhaseModel::IDPrecipitationDomain_optional& PrecipitationPhaseModel::
IDPrecipitationDomain () const
{
  return this->IDPrecipitationDomain_;
}

PrecipitationPhaseModel::IDPrecipitationDomain_optional& PrecipitationPhaseModel::
IDPrecipitationDomain ()
{
  return this->IDPrecipitationDomain_;
}

void PrecipitationPhaseModel::
IDPrecipitationDomain (const IDPrecipitationDomain_type& x)
{
  this->IDPrecipitationDomain_.set (x);
}

void PrecipitationPhaseModel::
IDPrecipitationDomain (const IDPrecipitationDomain_optional& x)
{
  this->IDPrecipitationDomain_ = x;
}


// ProjectModel
// 

const ProjectModel::Id_optional& ProjectModel::
Id () const
{
  return this->Id_;
}

ProjectModel::Id_optional& ProjectModel::
Id ()
{
  return this->Id_;
}

void ProjectModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void ProjectModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const ProjectModel::Name_optional& ProjectModel::
Name () const
{
  return this->Name_;
}

ProjectModel::Name_optional& ProjectModel::
Name ()
{
  return this->Name_;
}

void ProjectModel::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void ProjectModel::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void ProjectModel::
Name (::std::unique_ptr< Name_type > x)
{
  this->Name_.set (std::move (x));
}

const ProjectModel::APIName_optional& ProjectModel::
APIName () const
{
  return this->APIName_;
}

ProjectModel::APIName_optional& ProjectModel::
APIName ()
{
  return this->APIName_;
}

void ProjectModel::
APIName (const APIName_type& x)
{
  this->APIName_.set (x);
}

void ProjectModel::
APIName (const APIName_optional& x)
{
  this->APIName_ = x;
}

void ProjectModel::
APIName (::std::unique_ptr< APIName_type > x)
{
  this->APIName_.set (std::move (x));
}

const ProjectModel::External_APIName_optional& ProjectModel::
External_APIName () const
{
  return this->External_APIName_;
}

ProjectModel::External_APIName_optional& ProjectModel::
External_APIName ()
{
  return this->External_APIName_;
}

void ProjectModel::
External_APIName (const External_APIName_type& x)
{
  this->External_APIName_.set (x);
}

void ProjectModel::
External_APIName (const External_APIName_optional& x)
{
  this->External_APIName_ = x;
}

void ProjectModel::
External_APIName (::std::unique_ptr< External_APIName_type > x)
{
  this->External_APIName_.set (std::move (x));
}


// ScheilConfigurationModel
// 

const ScheilConfigurationModel::Id_optional& ScheilConfigurationModel::
Id () const
{
  return this->Id_;
}

ScheilConfigurationModel::Id_optional& ScheilConfigurationModel::
Id ()
{
  return this->Id_;
}

void ScheilConfigurationModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void ScheilConfigurationModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const ScheilConfigurationModel::IDCase_optional& ScheilConfigurationModel::
IDCase () const
{
  return this->IDCase_;
}

ScheilConfigurationModel::IDCase_optional& ScheilConfigurationModel::
IDCase ()
{
  return this->IDCase_;
}

void ScheilConfigurationModel::
IDCase (const IDCase_type& x)
{
  this->IDCase_.set (x);
}

void ScheilConfigurationModel::
IDCase (const IDCase_optional& x)
{
  this->IDCase_ = x;
}

const ScheilConfigurationModel::StartTemperature_optional& ScheilConfigurationModel::
StartTemperature () const
{
  return this->StartTemperature_;
}

ScheilConfigurationModel::StartTemperature_optional& ScheilConfigurationModel::
StartTemperature ()
{
  return this->StartTemperature_;
}

void ScheilConfigurationModel::
StartTemperature (const StartTemperature_type& x)
{
  this->StartTemperature_.set (x);
}

void ScheilConfigurationModel::
StartTemperature (const StartTemperature_optional& x)
{
  this->StartTemperature_ = x;
}

const ScheilConfigurationModel::EndTemperature_optional& ScheilConfigurationModel::
EndTemperature () const
{
  return this->EndTemperature_;
}

ScheilConfigurationModel::EndTemperature_optional& ScheilConfigurationModel::
EndTemperature ()
{
  return this->EndTemperature_;
}

void ScheilConfigurationModel::
EndTemperature (const EndTemperature_type& x)
{
  this->EndTemperature_.set (x);
}

void ScheilConfigurationModel::
EndTemperature (const EndTemperature_optional& x)
{
  this->EndTemperature_ = x;
}

const ScheilConfigurationModel::StepSize_optional& ScheilConfigurationModel::
StepSize () const
{
  return this->StepSize_;
}

ScheilConfigurationModel::StepSize_optional& ScheilConfigurationModel::
StepSize ()
{
  return this->StepSize_;
}

void ScheilConfigurationModel::
StepSize (const StepSize_type& x)
{
  this->StepSize_.set (x);
}

void ScheilConfigurationModel::
StepSize (const StepSize_optional& x)
{
  this->StepSize_ = x;
}

const ScheilConfigurationModel::DependentPhase_optional& ScheilConfigurationModel::
DependentPhase () const
{
  return this->DependentPhase_;
}

ScheilConfigurationModel::DependentPhase_optional& ScheilConfigurationModel::
DependentPhase ()
{
  return this->DependentPhase_;
}

void ScheilConfigurationModel::
DependentPhase (const DependentPhase_type& x)
{
  this->DependentPhase_.set (x);
}

void ScheilConfigurationModel::
DependentPhase (const DependentPhase_optional& x)
{
  this->DependentPhase_ = x;
}

const ScheilConfigurationModel::MinimumLiquidFraction_optional& ScheilConfigurationModel::
MinimumLiquidFraction () const
{
  return this->MinimumLiquidFraction_;
}

ScheilConfigurationModel::MinimumLiquidFraction_optional& ScheilConfigurationModel::
MinimumLiquidFraction ()
{
  return this->MinimumLiquidFraction_;
}

void ScheilConfigurationModel::
MinimumLiquidFraction (const MinimumLiquidFraction_type& x)
{
  this->MinimumLiquidFraction_.set (x);
}

void ScheilConfigurationModel::
MinimumLiquidFraction (const MinimumLiquidFraction_optional& x)
{
  this->MinimumLiquidFraction_ = x;
}


// ScheilCumulativeFractionModel
// 

const ScheilCumulativeFractionModel::Id_optional& ScheilCumulativeFractionModel::
Id () const
{
  return this->Id_;
}

ScheilCumulativeFractionModel::Id_optional& ScheilCumulativeFractionModel::
Id ()
{
  return this->Id_;
}

void ScheilCumulativeFractionModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void ScheilCumulativeFractionModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const ScheilCumulativeFractionModel::IDCase_optional& ScheilCumulativeFractionModel::
IDCase () const
{
  return this->IDCase_;
}

ScheilCumulativeFractionModel::IDCase_optional& ScheilCumulativeFractionModel::
IDCase ()
{
  return this->IDCase_;
}

void ScheilCumulativeFractionModel::
IDCase (const IDCase_type& x)
{
  this->IDCase_.set (x);
}

void ScheilCumulativeFractionModel::
IDCase (const IDCase_optional& x)
{
  this->IDCase_ = x;
}

const ScheilCumulativeFractionModel::IDPhase_optional& ScheilCumulativeFractionModel::
IDPhase () const
{
  return this->IDPhase_;
}

ScheilCumulativeFractionModel::IDPhase_optional& ScheilCumulativeFractionModel::
IDPhase ()
{
  return this->IDPhase_;
}

void ScheilCumulativeFractionModel::
IDPhase (const IDPhase_type& x)
{
  this->IDPhase_.set (x);
}

void ScheilCumulativeFractionModel::
IDPhase (const IDPhase_optional& x)
{
  this->IDPhase_ = x;
}

const ScheilCumulativeFractionModel::TypeComposition_optional& ScheilCumulativeFractionModel::
TypeComposition () const
{
  return this->TypeComposition_;
}

ScheilCumulativeFractionModel::TypeComposition_optional& ScheilCumulativeFractionModel::
TypeComposition ()
{
  return this->TypeComposition_;
}

void ScheilCumulativeFractionModel::
TypeComposition (const TypeComposition_type& x)
{
  this->TypeComposition_.set (x);
}

void ScheilCumulativeFractionModel::
TypeComposition (const TypeComposition_optional& x)
{
  this->TypeComposition_ = x;
}

void ScheilCumulativeFractionModel::
TypeComposition (::std::unique_ptr< TypeComposition_type > x)
{
  this->TypeComposition_.set (std::move (x));
}

const ScheilCumulativeFractionModel::Temperature_optional& ScheilCumulativeFractionModel::
Temperature () const
{
  return this->Temperature_;
}

ScheilCumulativeFractionModel::Temperature_optional& ScheilCumulativeFractionModel::
Temperature ()
{
  return this->Temperature_;
}

void ScheilCumulativeFractionModel::
Temperature (const Temperature_type& x)
{
  this->Temperature_.set (x);
}

void ScheilCumulativeFractionModel::
Temperature (const Temperature_optional& x)
{
  this->Temperature_ = x;
}

const ScheilCumulativeFractionModel::Value_optional& ScheilCumulativeFractionModel::
Value () const
{
  return this->Value_;
}

ScheilCumulativeFractionModel::Value_optional& ScheilCumulativeFractionModel::
Value ()
{
  return this->Value_;
}

void ScheilCumulativeFractionModel::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ScheilCumulativeFractionModel::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// ScheilPhaseFractionModel
// 

const ScheilPhaseFractionModel::Id_optional& ScheilPhaseFractionModel::
Id () const
{
  return this->Id_;
}

ScheilPhaseFractionModel::Id_optional& ScheilPhaseFractionModel::
Id ()
{
  return this->Id_;
}

void ScheilPhaseFractionModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void ScheilPhaseFractionModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const ScheilPhaseFractionModel::IDCase_optional& ScheilPhaseFractionModel::
IDCase () const
{
  return this->IDCase_;
}

ScheilPhaseFractionModel::IDCase_optional& ScheilPhaseFractionModel::
IDCase ()
{
  return this->IDCase_;
}

void ScheilPhaseFractionModel::
IDCase (const IDCase_type& x)
{
  this->IDCase_.set (x);
}

void ScheilPhaseFractionModel::
IDCase (const IDCase_optional& x)
{
  this->IDCase_ = x;
}

const ScheilPhaseFractionModel::IDPhase_optional& ScheilPhaseFractionModel::
IDPhase () const
{
  return this->IDPhase_;
}

ScheilPhaseFractionModel::IDPhase_optional& ScheilPhaseFractionModel::
IDPhase ()
{
  return this->IDPhase_;
}

void ScheilPhaseFractionModel::
IDPhase (const IDPhase_type& x)
{
  this->IDPhase_.set (x);
}

void ScheilPhaseFractionModel::
IDPhase (const IDPhase_optional& x)
{
  this->IDPhase_ = x;
}

const ScheilPhaseFractionModel::TypeComposition_optional& ScheilPhaseFractionModel::
TypeComposition () const
{
  return this->TypeComposition_;
}

ScheilPhaseFractionModel::TypeComposition_optional& ScheilPhaseFractionModel::
TypeComposition ()
{
  return this->TypeComposition_;
}

void ScheilPhaseFractionModel::
TypeComposition (const TypeComposition_type& x)
{
  this->TypeComposition_.set (x);
}

void ScheilPhaseFractionModel::
TypeComposition (const TypeComposition_optional& x)
{
  this->TypeComposition_ = x;
}

void ScheilPhaseFractionModel::
TypeComposition (::std::unique_ptr< TypeComposition_type > x)
{
  this->TypeComposition_.set (std::move (x));
}

const ScheilPhaseFractionModel::Temperature_optional& ScheilPhaseFractionModel::
Temperature () const
{
  return this->Temperature_;
}

ScheilPhaseFractionModel::Temperature_optional& ScheilPhaseFractionModel::
Temperature ()
{
  return this->Temperature_;
}

void ScheilPhaseFractionModel::
Temperature (const Temperature_type& x)
{
  this->Temperature_.set (x);
}

void ScheilPhaseFractionModel::
Temperature (const Temperature_optional& x)
{
  this->Temperature_ = x;
}

const ScheilPhaseFractionModel::Value_optional& ScheilPhaseFractionModel::
Value () const
{
  return this->Value_;
}

ScheilPhaseFractionModel::Value_optional& ScheilPhaseFractionModel::
Value ()
{
  return this->Value_;
}

void ScheilPhaseFractionModel::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void ScheilPhaseFractionModel::
Value (const Value_optional& x)
{
  this->Value_ = x;
}


// SelectedElementsModel
// 

const SelectedElementsModel::Id_optional& SelectedElementsModel::
Id () const
{
  return this->Id_;
}

SelectedElementsModel::Id_optional& SelectedElementsModel::
Id ()
{
  return this->Id_;
}

void SelectedElementsModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void SelectedElementsModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const SelectedElementsModel::IDProject_optional& SelectedElementsModel::
IDProject () const
{
  return this->IDProject_;
}

SelectedElementsModel::IDProject_optional& SelectedElementsModel::
IDProject ()
{
  return this->IDProject_;
}

void SelectedElementsModel::
IDProject (const IDProject_type& x)
{
  this->IDProject_.set (x);
}

void SelectedElementsModel::
IDProject (const IDProject_optional& x)
{
  this->IDProject_ = x;
}

const SelectedElementsModel::IDElement_optional& SelectedElementsModel::
IDElement () const
{
  return this->IDElement_;
}

SelectedElementsModel::IDElement_optional& SelectedElementsModel::
IDElement ()
{
  return this->IDElement_;
}

void SelectedElementsModel::
IDElement (const IDElement_type& x)
{
  this->IDElement_.set (x);
}

void SelectedElementsModel::
IDElement (const IDElement_optional& x)
{
  this->IDElement_ = x;
}

const SelectedElementsModel::IsReferenceElement_optional& SelectedElementsModel::
IsReferenceElement () const
{
  return this->IsReferenceElement_;
}

SelectedElementsModel::IsReferenceElement_optional& SelectedElementsModel::
IsReferenceElement ()
{
  return this->IsReferenceElement_;
}

void SelectedElementsModel::
IsReferenceElement (const IsReferenceElement_type& x)
{
  this->IsReferenceElement_.set (x);
}

void SelectedElementsModel::
IsReferenceElement (const IsReferenceElement_optional& x)
{
  this->IsReferenceElement_ = x;
}


// SelectedPhasesModel
// 

const SelectedPhasesModel::Id_optional& SelectedPhasesModel::
Id () const
{
  return this->Id_;
}

SelectedPhasesModel::Id_optional& SelectedPhasesModel::
Id ()
{
  return this->Id_;
}

void SelectedPhasesModel::
Id (const Id_type& x)
{
  this->Id_.set (x);
}

void SelectedPhasesModel::
Id (const Id_optional& x)
{
  this->Id_ = x;
}

const SelectedPhasesModel::IDCase_optional& SelectedPhasesModel::
IDCase () const
{
  return this->IDCase_;
}

SelectedPhasesModel::IDCase_optional& SelectedPhasesModel::
IDCase ()
{
  return this->IDCase_;
}

void SelectedPhasesModel::
IDCase (const IDCase_type& x)
{
  this->IDCase_.set (x);
}

void SelectedPhasesModel::
IDCase (const IDCase_optional& x)
{
  this->IDCase_ = x;
}

const SelectedPhasesModel::IDPhase_optional& SelectedPhasesModel::
IDPhase () const
{
  return this->IDPhase_;
}

SelectedPhasesModel::IDPhase_optional& SelectedPhasesModel::
IDPhase ()
{
  return this->IDPhase_;
}

void SelectedPhasesModel::
IDPhase (const IDPhase_type& x)
{
  this->IDPhase_.set (x);
}

void SelectedPhasesModel::
IDPhase (const IDPhase_optional& x)
{
  this->IDPhase_ = x;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// ActivePhasesModel
//

ActivePhasesModel::
ActivePhasesModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDProject_ (this),
  IDPhase_ (this)
{
}

ActivePhasesModel::
ActivePhasesModel (const ActivePhasesModel& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDProject_ (x.IDProject_, f, this),
  IDPhase_ (x.IDPhase_, f, this)
{
}

ActivePhasesModel::
ActivePhasesModel (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDProject_ (this),
  IDPhase_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ActivePhasesModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDProject" && n.namespace_ ().empty ())
    {
      this->IDProject_.set (IDProject_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDPhase" && n.namespace_ ().empty ())
    {
      this->IDPhase_.set (IDPhase_traits::create (i, f, this));
      continue;
    }
  }
}

ActivePhasesModel* ActivePhasesModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ActivePhasesModel (*this, f, c);
}

ActivePhasesModel& ActivePhasesModel::
operator= (const ActivePhasesModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDProject_ = x.IDProject_;
    this->IDPhase_ = x.IDPhase_;
  }

  return *this;
}

ActivePhasesModel::
~ActivePhasesModel ()
{
}

bool
operator== (const ActivePhasesModel& x, const ActivePhasesModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDProject () == y.IDProject ()))
    return false;

  if (!(x.IDPhase () == y.IDPhase ()))
    return false;

  return true;
}

bool
operator!= (const ActivePhasesModel& x, const ActivePhasesModel& y)
{
  return !(x == y);
}

// ActivePhasesConfigurationModel
//

ActivePhasesConfigurationModel::
ActivePhasesConfigurationModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDProject_ (this),
  StartTemp_ (this),
  EndTemp_ (this),
  StepSize_ (this)
{
}

ActivePhasesConfigurationModel::
ActivePhasesConfigurationModel (const ActivePhasesConfigurationModel& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDProject_ (x.IDProject_, f, this),
  StartTemp_ (x.StartTemp_, f, this),
  EndTemp_ (x.EndTemp_, f, this),
  StepSize_ (x.StepSize_, f, this)
{
}

ActivePhasesConfigurationModel::
ActivePhasesConfigurationModel (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDProject_ (this),
  StartTemp_ (this),
  EndTemp_ (this),
  StepSize_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ActivePhasesConfigurationModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDProject" && n.namespace_ ().empty ())
    {
      this->IDProject_.set (IDProject_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "StartTemp" && n.namespace_ ().empty ())
    {
      this->StartTemp_.set (StartTemp_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "EndTemp" && n.namespace_ ().empty ())
    {
      this->EndTemp_.set (EndTemp_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "StepSize" && n.namespace_ ().empty ())
    {
      this->StepSize_.set (StepSize_traits::create (i, f, this));
      continue;
    }
  }
}

ActivePhasesConfigurationModel* ActivePhasesConfigurationModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ActivePhasesConfigurationModel (*this, f, c);
}

ActivePhasesConfigurationModel& ActivePhasesConfigurationModel::
operator= (const ActivePhasesConfigurationModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDProject_ = x.IDProject_;
    this->StartTemp_ = x.StartTemp_;
    this->EndTemp_ = x.EndTemp_;
    this->StepSize_ = x.StepSize_;
  }

  return *this;
}

ActivePhasesConfigurationModel::
~ActivePhasesConfigurationModel ()
{
}

bool
operator== (const ActivePhasesConfigurationModel& x, const ActivePhasesConfigurationModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDProject () == y.IDProject ()))
    return false;

  if (!(x.StartTemp () == y.StartTemp ()))
    return false;

  if (!(x.EndTemp () == y.EndTemp ()))
    return false;

  if (!(x.StepSize () == y.StepSize ()))
    return false;

  return true;
}

bool
operator!= (const ActivePhasesConfigurationModel& x, const ActivePhasesConfigurationModel& y)
{
  return !(x == y);
}

// ActivePhasesElementCompositionModel
//

ActivePhasesElementCompositionModel::
ActivePhasesElementCompositionModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDProject_ (this),
  IDElement_ (this),
  Value_ (this)
{
}

ActivePhasesElementCompositionModel::
ActivePhasesElementCompositionModel (const ActivePhasesElementCompositionModel& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDProject_ (x.IDProject_, f, this),
  IDElement_ (x.IDElement_, f, this),
  Value_ (x.Value_, f, this)
{
}

ActivePhasesElementCompositionModel::
ActivePhasesElementCompositionModel (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDProject_ (this),
  IDElement_ (this),
  Value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ActivePhasesElementCompositionModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDProject" && n.namespace_ ().empty ())
    {
      this->IDProject_.set (IDProject_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDElement" && n.namespace_ ().empty ())
    {
      this->IDElement_.set (IDElement_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ActivePhasesElementCompositionModel* ActivePhasesElementCompositionModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ActivePhasesElementCompositionModel (*this, f, c);
}

ActivePhasesElementCompositionModel& ActivePhasesElementCompositionModel::
operator= (const ActivePhasesElementCompositionModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDProject_ = x.IDProject_;
    this->IDElement_ = x.IDElement_;
    this->Value_ = x.Value_;
  }

  return *this;
}

ActivePhasesElementCompositionModel::
~ActivePhasesElementCompositionModel ()
{
}

bool
operator== (const ActivePhasesElementCompositionModel& x, const ActivePhasesElementCompositionModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDProject () == y.IDProject ()))
    return false;

  if (!(x.IDElement () == y.IDElement ()))
    return false;

  if (!(x.Value () == y.Value ()))
    return false;

  return true;
}

bool
operator!= (const ActivePhasesElementCompositionModel& x, const ActivePhasesElementCompositionModel& y)
{
  return !(x == y);
}

// CALPHADDatabaseModel
//

CALPHADDatabaseModel::
CALPHADDatabaseModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDProject_ (this),
  Thermodynamic_ (this),
  Physical_ (this),
  Mobility_ (this)
{
}

CALPHADDatabaseModel::
CALPHADDatabaseModel (const CALPHADDatabaseModel& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDProject_ (x.IDProject_, f, this),
  Thermodynamic_ (x.Thermodynamic_, f, this),
  Physical_ (x.Physical_, f, this),
  Mobility_ (x.Mobility_, f, this)
{
}

CALPHADDatabaseModel::
CALPHADDatabaseModel (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDProject_ (this),
  Thermodynamic_ (this),
  Physical_ (this),
  Mobility_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void CALPHADDatabaseModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDProject" && n.namespace_ ().empty ())
    {
      this->IDProject_.set (IDProject_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Thermodynamic" && n.namespace_ ().empty ())
    {
      this->Thermodynamic_.set (Thermodynamic_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Physical" && n.namespace_ ().empty ())
    {
      this->Physical_.set (Physical_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Mobility" && n.namespace_ ().empty ())
    {
      this->Mobility_.set (Mobility_traits::create (i, f, this));
      continue;
    }
  }
}

CALPHADDatabaseModel* CALPHADDatabaseModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CALPHADDatabaseModel (*this, f, c);
}

CALPHADDatabaseModel& CALPHADDatabaseModel::
operator= (const CALPHADDatabaseModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDProject_ = x.IDProject_;
    this->Thermodynamic_ = x.Thermodynamic_;
    this->Physical_ = x.Physical_;
    this->Mobility_ = x.Mobility_;
  }

  return *this;
}

CALPHADDatabaseModel::
~CALPHADDatabaseModel ()
{
}

bool
operator== (const CALPHADDatabaseModel& x, const CALPHADDatabaseModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDProject () == y.IDProject ()))
    return false;

  if (!(x.Thermodynamic () == y.Thermodynamic ()))
    return false;

  if (!(x.Physical () == y.Physical ()))
    return false;

  if (!(x.Mobility () == y.Mobility ()))
    return false;

  return true;
}

bool
operator!= (const CALPHADDatabaseModel& x, const CALPHADDatabaseModel& y)
{
  return !(x == y);
}

// CaseModel
//

CaseModel::
CaseModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDProject_ (this),
  IDGroup_ (this),
  Name_ (this),
  Script_ (this),
  Date_ (this),
  PosX_ (this),
  PosY_ (this),
  PosZ_ (this)
{
}

CaseModel::
CaseModel (const CaseModel& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDProject_ (x.IDProject_, f, this),
  IDGroup_ (x.IDGroup_, f, this),
  Name_ (x.Name_, f, this),
  Script_ (x.Script_, f, this),
  Date_ (x.Date_, f, this),
  PosX_ (x.PosX_, f, this),
  PosY_ (x.PosY_, f, this),
  PosZ_ (x.PosZ_, f, this)
{
}

CaseModel::
CaseModel (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDProject_ (this),
  IDGroup_ (this),
  Name_ (this),
  Script_ (this),
  Date_ (this),
  PosX_ (this),
  PosY_ (this),
  PosZ_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void CaseModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDProject" && n.namespace_ ().empty ())
    {
      this->IDProject_.set (IDProject_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDGroup" && n.namespace_ ().empty ())
    {
      this->IDGroup_.set (IDGroup_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Script" && n.namespace_ ().empty ())
    {
      this->Script_.set (Script_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Date" && n.namespace_ ().empty ())
    {
      this->Date_.set (Date_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "PosX" && n.namespace_ ().empty ())
    {
      this->PosX_.set (PosX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "PosY" && n.namespace_ ().empty ())
    {
      this->PosY_.set (PosY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "PosZ" && n.namespace_ ().empty ())
    {
      this->PosZ_.set (PosZ_traits::create (i, f, this));
      continue;
    }
  }
}

CaseModel* CaseModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CaseModel (*this, f, c);
}

CaseModel& CaseModel::
operator= (const CaseModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDProject_ = x.IDProject_;
    this->IDGroup_ = x.IDGroup_;
    this->Name_ = x.Name_;
    this->Script_ = x.Script_;
    this->Date_ = x.Date_;
    this->PosX_ = x.PosX_;
    this->PosY_ = x.PosY_;
    this->PosZ_ = x.PosZ_;
  }

  return *this;
}

CaseModel::
~CaseModel ()
{
}

bool
operator== (const CaseModel& x, const CaseModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDProject () == y.IDProject ()))
    return false;

  if (!(x.IDGroup () == y.IDGroup ()))
    return false;

  if (!(x.Name () == y.Name ()))
    return false;

  if (!(x.Script () == y.Script ()))
    return false;

  if (!(x.Date () == y.Date ()))
    return false;

  if (!(x.PosX () == y.PosX ()))
    return false;

  if (!(x.PosY () == y.PosY ()))
    return false;

  if (!(x.PosZ () == y.PosZ ()))
    return false;

  return true;
}

bool
operator!= (const CaseModel& x, const CaseModel& y)
{
  return !(x == y);
}

// ElementModel
//

ElementModel::
ElementModel ()
: ::xml_schema::type (),
  Id_ (this),
  Name_ (this)
{
}

ElementModel::
ElementModel (const ElementModel& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  Name_ (x.Name_, f, this)
{
}

ElementModel::
ElementModel (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ElementModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

ElementModel* ElementModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ElementModel (*this, f, c);
}

ElementModel& ElementModel::
operator= (const ElementModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->Name_ = x.Name_;
  }

  return *this;
}

ElementModel::
~ElementModel ()
{
}

bool
operator== (const ElementModel& x, const ElementModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.Name () == y.Name ()))
    return false;

  return true;
}

bool
operator!= (const ElementModel& x, const ElementModel& y)
{
  return !(x == y);
}

// ElementCompositionModel
//

ElementCompositionModel::
ElementCompositionModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDCase_ (this),
  IDElement_ (this),
  TypeComposition_ (this),
  Value_ (this)
{
}

ElementCompositionModel::
ElementCompositionModel (const ElementCompositionModel& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDCase_ (x.IDCase_, f, this),
  IDElement_ (x.IDElement_, f, this),
  TypeComposition_ (x.TypeComposition_, f, this),
  Value_ (x.Value_, f, this)
{
}

ElementCompositionModel::
ElementCompositionModel (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDCase_ (this),
  IDElement_ (this),
  TypeComposition_ (this),
  Value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ElementCompositionModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDCase" && n.namespace_ ().empty ())
    {
      this->IDCase_.set (IDCase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDElement" && n.namespace_ ().empty ())
    {
      this->IDElement_.set (IDElement_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "TypeComposition" && n.namespace_ ().empty ())
    {
      this->TypeComposition_.set (TypeComposition_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ElementCompositionModel* ElementCompositionModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ElementCompositionModel (*this, f, c);
}

ElementCompositionModel& ElementCompositionModel::
operator= (const ElementCompositionModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDCase_ = x.IDCase_;
    this->IDElement_ = x.IDElement_;
    this->TypeComposition_ = x.TypeComposition_;
    this->Value_ = x.Value_;
  }

  return *this;
}

ElementCompositionModel::
~ElementCompositionModel ()
{
}

bool
operator== (const ElementCompositionModel& x, const ElementCompositionModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDCase () == y.IDCase ()))
    return false;

  if (!(x.IDElement () == y.IDElement ()))
    return false;

  if (!(x.TypeComposition () == y.TypeComposition ()))
    return false;

  if (!(x.Value () == y.Value ()))
    return false;

  return true;
}

bool
operator!= (const ElementCompositionModel& x, const ElementCompositionModel& y)
{
  return !(x == y);
}

// EquilibriumConfigurationModel
//

EquilibriumConfigurationModel::
EquilibriumConfigurationModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDCase_ (this),
  Temperature_ (this),
  StartTemperature_ (this),
  EndTemperature_ (this),
  TemperatureType_ (this),
  StepSize_ (this),
  Pressure_ (this)
{
}

EquilibriumConfigurationModel::
EquilibriumConfigurationModel (const EquilibriumConfigurationModel& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDCase_ (x.IDCase_, f, this),
  Temperature_ (x.Temperature_, f, this),
  StartTemperature_ (x.StartTemperature_, f, this),
  EndTemperature_ (x.EndTemperature_, f, this),
  TemperatureType_ (x.TemperatureType_, f, this),
  StepSize_ (x.StepSize_, f, this),
  Pressure_ (x.Pressure_, f, this)
{
}

EquilibriumConfigurationModel::
EquilibriumConfigurationModel (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDCase_ (this),
  Temperature_ (this),
  StartTemperature_ (this),
  EndTemperature_ (this),
  TemperatureType_ (this),
  StepSize_ (this),
  Pressure_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void EquilibriumConfigurationModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDCase" && n.namespace_ ().empty ())
    {
      this->IDCase_.set (IDCase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Temperature" && n.namespace_ ().empty ())
    {
      this->Temperature_.set (Temperature_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "StartTemperature" && n.namespace_ ().empty ())
    {
      this->StartTemperature_.set (StartTemperature_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "EndTemperature" && n.namespace_ ().empty ())
    {
      this->EndTemperature_.set (EndTemperature_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "TemperatureType" && n.namespace_ ().empty ())
    {
      this->TemperatureType_.set (TemperatureType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "StepSize" && n.namespace_ ().empty ())
    {
      this->StepSize_.set (StepSize_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Pressure" && n.namespace_ ().empty ())
    {
      this->Pressure_.set (Pressure_traits::create (i, f, this));
      continue;
    }
  }
}

EquilibriumConfigurationModel* EquilibriumConfigurationModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EquilibriumConfigurationModel (*this, f, c);
}

EquilibriumConfigurationModel& EquilibriumConfigurationModel::
operator= (const EquilibriumConfigurationModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDCase_ = x.IDCase_;
    this->Temperature_ = x.Temperature_;
    this->StartTemperature_ = x.StartTemperature_;
    this->EndTemperature_ = x.EndTemperature_;
    this->TemperatureType_ = x.TemperatureType_;
    this->StepSize_ = x.StepSize_;
    this->Pressure_ = x.Pressure_;
  }

  return *this;
}

EquilibriumConfigurationModel::
~EquilibriumConfigurationModel ()
{
}

bool
operator== (const EquilibriumConfigurationModel& x, const EquilibriumConfigurationModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDCase () == y.IDCase ()))
    return false;

  if (!(x.Temperature () == y.Temperature ()))
    return false;

  if (!(x.StartTemperature () == y.StartTemperature ()))
    return false;

  if (!(x.EndTemperature () == y.EndTemperature ()))
    return false;

  if (!(x.TemperatureType () == y.TemperatureType ()))
    return false;

  if (!(x.StepSize () == y.StepSize ()))
    return false;

  if (!(x.Pressure () == y.Pressure ()))
    return false;

  return true;
}

bool
operator!= (const EquilibriumConfigurationModel& x, const EquilibriumConfigurationModel& y)
{
  return !(x == y);
}

// EquilibriumPhaseFractionModel
//

EquilibriumPhaseFractionModel::
EquilibriumPhaseFractionModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDCase_ (this),
  Temperature_ (this),
  Value_ (this)
{
}

EquilibriumPhaseFractionModel::
EquilibriumPhaseFractionModel (const EquilibriumPhaseFractionModel& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDCase_ (x.IDCase_, f, this),
  Temperature_ (x.Temperature_, f, this),
  Value_ (x.Value_, f, this)
{
}

EquilibriumPhaseFractionModel::
EquilibriumPhaseFractionModel (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDCase_ (this),
  Temperature_ (this),
  Value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void EquilibriumPhaseFractionModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDCase" && n.namespace_ ().empty ())
    {
      this->IDCase_.set (IDCase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Temperature" && n.namespace_ ().empty ())
    {
      this->Temperature_.set (Temperature_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

EquilibriumPhaseFractionModel* EquilibriumPhaseFractionModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EquilibriumPhaseFractionModel (*this, f, c);
}

EquilibriumPhaseFractionModel& EquilibriumPhaseFractionModel::
operator= (const EquilibriumPhaseFractionModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDCase_ = x.IDCase_;
    this->Temperature_ = x.Temperature_;
    this->Value_ = x.Value_;
  }

  return *this;
}

EquilibriumPhaseFractionModel::
~EquilibriumPhaseFractionModel ()
{
}

bool
operator== (const EquilibriumPhaseFractionModel& x, const EquilibriumPhaseFractionModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDCase () == y.IDCase ()))
    return false;

  if (!(x.Temperature () == y.Temperature ()))
    return false;

  if (!(x.Value () == y.Value ()))
    return false;

  return true;
}

bool
operator!= (const EquilibriumPhaseFractionModel& x, const EquilibriumPhaseFractionModel& y)
{
  return !(x == y);
}

// HeatTreatmentModel
//

HeatTreatmentModel::
HeatTreatmentModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDCase_ (this),
  Name_ (this),
  MaxTemperatureStep_ (this),
  IDPrecipitationDomain_ (this),
  StartTemperature_ (this)
{
}

HeatTreatmentModel::
HeatTreatmentModel (const HeatTreatmentModel& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDCase_ (x.IDCase_, f, this),
  Name_ (x.Name_, f, this),
  MaxTemperatureStep_ (x.MaxTemperatureStep_, f, this),
  IDPrecipitationDomain_ (x.IDPrecipitationDomain_, f, this),
  StartTemperature_ (x.StartTemperature_, f, this)
{
}

HeatTreatmentModel::
HeatTreatmentModel (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDCase_ (this),
  Name_ (this),
  MaxTemperatureStep_ (this),
  IDPrecipitationDomain_ (this),
  StartTemperature_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void HeatTreatmentModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDCase" && n.namespace_ ().empty ())
    {
      this->IDCase_.set (IDCase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MaxTemperatureStep" && n.namespace_ ().empty ())
    {
      this->MaxTemperatureStep_.set (MaxTemperatureStep_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDPrecipitationDomain" && n.namespace_ ().empty ())
    {
      this->IDPrecipitationDomain_.set (IDPrecipitationDomain_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "StartTemperature" && n.namespace_ ().empty ())
    {
      this->StartTemperature_.set (StartTemperature_traits::create (i, f, this));
      continue;
    }
  }
}

HeatTreatmentModel* HeatTreatmentModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class HeatTreatmentModel (*this, f, c);
}

HeatTreatmentModel& HeatTreatmentModel::
operator= (const HeatTreatmentModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDCase_ = x.IDCase_;
    this->Name_ = x.Name_;
    this->MaxTemperatureStep_ = x.MaxTemperatureStep_;
    this->IDPrecipitationDomain_ = x.IDPrecipitationDomain_;
    this->StartTemperature_ = x.StartTemperature_;
  }

  return *this;
}

HeatTreatmentModel::
~HeatTreatmentModel ()
{
}

bool
operator== (const HeatTreatmentModel& x, const HeatTreatmentModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDCase () == y.IDCase ()))
    return false;

  if (!(x.Name () == y.Name ()))
    return false;

  if (!(x.MaxTemperatureStep () == y.MaxTemperatureStep ()))
    return false;

  if (!(x.IDPrecipitationDomain () == y.IDPrecipitationDomain ()))
    return false;

  if (!(x.StartTemperature () == y.StartTemperature ()))
    return false;

  return true;
}

bool
operator!= (const HeatTreatmentModel& x, const HeatTreatmentModel& y)
{
  return !(x == y);
}

// HeatTreatmentProfileModel
//

HeatTreatmentProfileModel::
HeatTreatmentProfileModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDHeatTreatment_ (this),
  Time_ (this),
  Temperature_ (this)
{
}

HeatTreatmentProfileModel::
HeatTreatmentProfileModel (const HeatTreatmentProfileModel& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDHeatTreatment_ (x.IDHeatTreatment_, f, this),
  Time_ (x.Time_, f, this),
  Temperature_ (x.Temperature_, f, this)
{
}

HeatTreatmentProfileModel::
HeatTreatmentProfileModel (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDHeatTreatment_ (this),
  Time_ (this),
  Temperature_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void HeatTreatmentProfileModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDHeatTreatment" && n.namespace_ ().empty ())
    {
      this->IDHeatTreatment_.set (IDHeatTreatment_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Time" && n.namespace_ ().empty ())
    {
      this->Time_.set (Time_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Temperature" && n.namespace_ ().empty ())
    {
      this->Temperature_.set (Temperature_traits::create (i, f, this));
      continue;
    }
  }
}

HeatTreatmentProfileModel* HeatTreatmentProfileModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class HeatTreatmentProfileModel (*this, f, c);
}

HeatTreatmentProfileModel& HeatTreatmentProfileModel::
operator= (const HeatTreatmentProfileModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDHeatTreatment_ = x.IDHeatTreatment_;
    this->Time_ = x.Time_;
    this->Temperature_ = x.Temperature_;
  }

  return *this;
}

HeatTreatmentProfileModel::
~HeatTreatmentProfileModel ()
{
}

bool
operator== (const HeatTreatmentProfileModel& x, const HeatTreatmentProfileModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDHeatTreatment () == y.IDHeatTreatment ()))
    return false;

  if (!(x.Time () == y.Time ()))
    return false;

  if (!(x.Temperature () == y.Temperature ()))
    return false;

  return true;
}

bool
operator!= (const HeatTreatmentProfileModel& x, const HeatTreatmentProfileModel& y)
{
  return !(x == y);
}

// HeatTreatmentSegmentModel
//

HeatTreatmentSegmentModel::
HeatTreatmentSegmentModel ()
: ::xml_schema::type (),
  Id_ (this),
  StepIndex_ (this),
  IDHeatTreatment_ (this),
  IDPrecipitationDomain_ (this),
  EndTemperature_ (this),
  TemperatureGradient_ (this),
  Duration_ (this)
{
}

HeatTreatmentSegmentModel::
HeatTreatmentSegmentModel (const HeatTreatmentSegmentModel& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  StepIndex_ (x.StepIndex_, f, this),
  IDHeatTreatment_ (x.IDHeatTreatment_, f, this),
  IDPrecipitationDomain_ (x.IDPrecipitationDomain_, f, this),
  EndTemperature_ (x.EndTemperature_, f, this),
  TemperatureGradient_ (x.TemperatureGradient_, f, this),
  Duration_ (x.Duration_, f, this)
{
}

HeatTreatmentSegmentModel::
HeatTreatmentSegmentModel (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  StepIndex_ (this),
  IDHeatTreatment_ (this),
  IDPrecipitationDomain_ (this),
  EndTemperature_ (this),
  TemperatureGradient_ (this),
  Duration_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void HeatTreatmentSegmentModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "StepIndex" && n.namespace_ ().empty ())
    {
      this->StepIndex_.set (StepIndex_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDHeatTreatment" && n.namespace_ ().empty ())
    {
      this->IDHeatTreatment_.set (IDHeatTreatment_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDPrecipitationDomain" && n.namespace_ ().empty ())
    {
      this->IDPrecipitationDomain_.set (IDPrecipitationDomain_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "EndTemperature" && n.namespace_ ().empty ())
    {
      this->EndTemperature_.set (EndTemperature_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "TemperatureGradient" && n.namespace_ ().empty ())
    {
      this->TemperatureGradient_.set (TemperatureGradient_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Duration" && n.namespace_ ().empty ())
    {
      this->Duration_.set (Duration_traits::create (i, f, this));
      continue;
    }
  }
}

HeatTreatmentSegmentModel* HeatTreatmentSegmentModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class HeatTreatmentSegmentModel (*this, f, c);
}

HeatTreatmentSegmentModel& HeatTreatmentSegmentModel::
operator= (const HeatTreatmentSegmentModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->StepIndex_ = x.StepIndex_;
    this->IDHeatTreatment_ = x.IDHeatTreatment_;
    this->IDPrecipitationDomain_ = x.IDPrecipitationDomain_;
    this->EndTemperature_ = x.EndTemperature_;
    this->TemperatureGradient_ = x.TemperatureGradient_;
    this->Duration_ = x.Duration_;
  }

  return *this;
}

HeatTreatmentSegmentModel::
~HeatTreatmentSegmentModel ()
{
}

bool
operator== (const HeatTreatmentSegmentModel& x, const HeatTreatmentSegmentModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.StepIndex () == y.StepIndex ()))
    return false;

  if (!(x.IDHeatTreatment () == y.IDHeatTreatment ()))
    return false;

  if (!(x.IDPrecipitationDomain () == y.IDPrecipitationDomain ()))
    return false;

  if (!(x.EndTemperature () == y.EndTemperature ()))
    return false;

  if (!(x.TemperatureGradient () == y.TemperatureGradient ()))
    return false;

  if (!(x.Duration () == y.Duration ()))
    return false;

  return true;
}

bool
operator!= (const HeatTreatmentSegmentModel& x, const HeatTreatmentSegmentModel& y)
{
  return !(x == y);
}

// PhaseModel
//

PhaseModel::
PhaseModel ()
: ::xml_schema::type (),
  Id_ (this),
  Name_ (this),
  DBType_ (this)
{
}

PhaseModel::
PhaseModel (const PhaseModel& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  Name_ (x.Name_, f, this),
  DBType_ (x.DBType_, f, this)
{
}

PhaseModel::
PhaseModel (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  Name_ (this),
  DBType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void PhaseModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "DBType" && n.namespace_ ().empty ())
    {
      this->DBType_.set (DBType_traits::create (i, f, this));
      continue;
    }
  }
}

PhaseModel* PhaseModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PhaseModel (*this, f, c);
}

PhaseModel& PhaseModel::
operator= (const PhaseModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->Name_ = x.Name_;
    this->DBType_ = x.DBType_;
  }

  return *this;
}

PhaseModel::
~PhaseModel ()
{
}

bool
operator== (const PhaseModel& x, const PhaseModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.Name () == y.Name ()))
    return false;

  if (!(x.DBType () == y.DBType ()))
    return false;

  return true;
}

bool
operator!= (const PhaseModel& x, const PhaseModel& y)
{
  return !(x == y);
}

// PrecipitationSimulationDataModel
//

PrecipitationSimulationDataModel::
PrecipitationSimulationDataModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDPrecipitationPhase_ (this),
  IDHeatTreatment_ (this),
  Time_ (this),
  PhaseFraction_ (this),
  NumberDensity_ (this),
  MeanRadius_ (this)
{
}

PrecipitationSimulationDataModel::
PrecipitationSimulationDataModel (const PrecipitationSimulationDataModel& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDPrecipitationPhase_ (x.IDPrecipitationPhase_, f, this),
  IDHeatTreatment_ (x.IDHeatTreatment_, f, this),
  Time_ (x.Time_, f, this),
  PhaseFraction_ (x.PhaseFraction_, f, this),
  NumberDensity_ (x.NumberDensity_, f, this),
  MeanRadius_ (x.MeanRadius_, f, this)
{
}

PrecipitationSimulationDataModel::
PrecipitationSimulationDataModel (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDPrecipitationPhase_ (this),
  IDHeatTreatment_ (this),
  Time_ (this),
  PhaseFraction_ (this),
  NumberDensity_ (this),
  MeanRadius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void PrecipitationSimulationDataModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDPrecipitationPhase" && n.namespace_ ().empty ())
    {
      this->IDPrecipitationPhase_.set (IDPrecipitationPhase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDHeatTreatment" && n.namespace_ ().empty ())
    {
      this->IDHeatTreatment_.set (IDHeatTreatment_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Time" && n.namespace_ ().empty ())
    {
      this->Time_.set (Time_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "PhaseFraction" && n.namespace_ ().empty ())
    {
      this->PhaseFraction_.set (PhaseFraction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "NumberDensity" && n.namespace_ ().empty ())
    {
      this->NumberDensity_.set (NumberDensity_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MeanRadius" && n.namespace_ ().empty ())
    {
      this->MeanRadius_.set (MeanRadius_traits::create (i, f, this));
      continue;
    }
  }
}

PrecipitationSimulationDataModel* PrecipitationSimulationDataModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PrecipitationSimulationDataModel (*this, f, c);
}

PrecipitationSimulationDataModel& PrecipitationSimulationDataModel::
operator= (const PrecipitationSimulationDataModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDPrecipitationPhase_ = x.IDPrecipitationPhase_;
    this->IDHeatTreatment_ = x.IDHeatTreatment_;
    this->Time_ = x.Time_;
    this->PhaseFraction_ = x.PhaseFraction_;
    this->NumberDensity_ = x.NumberDensity_;
    this->MeanRadius_ = x.MeanRadius_;
  }

  return *this;
}

PrecipitationSimulationDataModel::
~PrecipitationSimulationDataModel ()
{
}

bool
operator== (const PrecipitationSimulationDataModel& x, const PrecipitationSimulationDataModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDPrecipitationPhase () == y.IDPrecipitationPhase ()))
    return false;

  if (!(x.IDHeatTreatment () == y.IDHeatTreatment ()))
    return false;

  if (!(x.Time () == y.Time ()))
    return false;

  if (!(x.PhaseFraction () == y.PhaseFraction ()))
    return false;

  if (!(x.NumberDensity () == y.NumberDensity ()))
    return false;

  if (!(x.MeanRadius () == y.MeanRadius ()))
    return false;

  return true;
}

bool
operator!= (const PrecipitationSimulationDataModel& x, const PrecipitationSimulationDataModel& y)
{
  return !(x == y);
}

// PrecipitationDomainModel
//

PrecipitationDomainModel::
PrecipitationDomainModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDCase_ (this),
  Name_ (this),
  IDPhase_ (this),
  InitialGrainDiameter_ (this),
  EquilibriumDiDe_ (this)
{
}

PrecipitationDomainModel::
PrecipitationDomainModel (const PrecipitationDomainModel& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDCase_ (x.IDCase_, f, this),
  Name_ (x.Name_, f, this),
  IDPhase_ (x.IDPhase_, f, this),
  InitialGrainDiameter_ (x.InitialGrainDiameter_, f, this),
  EquilibriumDiDe_ (x.EquilibriumDiDe_, f, this)
{
}

PrecipitationDomainModel::
PrecipitationDomainModel (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDCase_ (this),
  Name_ (this),
  IDPhase_ (this),
  InitialGrainDiameter_ (this),
  EquilibriumDiDe_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void PrecipitationDomainModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDCase" && n.namespace_ ().empty ())
    {
      this->IDCase_.set (IDCase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDPhase" && n.namespace_ ().empty ())
    {
      this->IDPhase_.set (IDPhase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "InitialGrainDiameter" && n.namespace_ ().empty ())
    {
      this->InitialGrainDiameter_.set (InitialGrainDiameter_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "EquilibriumDiDe" && n.namespace_ ().empty ())
    {
      this->EquilibriumDiDe_.set (EquilibriumDiDe_traits::create (i, f, this));
      continue;
    }
  }
}

PrecipitationDomainModel* PrecipitationDomainModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PrecipitationDomainModel (*this, f, c);
}

PrecipitationDomainModel& PrecipitationDomainModel::
operator= (const PrecipitationDomainModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDCase_ = x.IDCase_;
    this->Name_ = x.Name_;
    this->IDPhase_ = x.IDPhase_;
    this->InitialGrainDiameter_ = x.InitialGrainDiameter_;
    this->EquilibriumDiDe_ = x.EquilibriumDiDe_;
  }

  return *this;
}

PrecipitationDomainModel::
~PrecipitationDomainModel ()
{
}

bool
operator== (const PrecipitationDomainModel& x, const PrecipitationDomainModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDCase () == y.IDCase ()))
    return false;

  if (!(x.Name () == y.Name ()))
    return false;

  if (!(x.IDPhase () == y.IDPhase ()))
    return false;

  if (!(x.InitialGrainDiameter () == y.InitialGrainDiameter ()))
    return false;

  if (!(x.EquilibriumDiDe () == y.EquilibriumDiDe ()))
    return false;

  return true;
}

bool
operator!= (const PrecipitationDomainModel& x, const PrecipitationDomainModel& y)
{
  return !(x == y);
}

// PrecipitationPhaseModel
//

PrecipitationPhaseModel::
PrecipitationPhaseModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDCase_ (this),
  IDPhase_ (this),
  NumberSizeClasses_ (this),
  Name_ (this),
  NucleationSites_ (this),
  IDPrecipitationDomain_ (this)
{
}

PrecipitationPhaseModel::
PrecipitationPhaseModel (const PrecipitationPhaseModel& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDCase_ (x.IDCase_, f, this),
  IDPhase_ (x.IDPhase_, f, this),
  NumberSizeClasses_ (x.NumberSizeClasses_, f, this),
  Name_ (x.Name_, f, this),
  NucleationSites_ (x.NucleationSites_, f, this),
  IDPrecipitationDomain_ (x.IDPrecipitationDomain_, f, this)
{
}

PrecipitationPhaseModel::
PrecipitationPhaseModel (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDCase_ (this),
  IDPhase_ (this),
  NumberSizeClasses_ (this),
  Name_ (this),
  NucleationSites_ (this),
  IDPrecipitationDomain_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void PrecipitationPhaseModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDCase" && n.namespace_ ().empty ())
    {
      this->IDCase_.set (IDCase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDPhase" && n.namespace_ ().empty ())
    {
      this->IDPhase_.set (IDPhase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "NumberSizeClasses" && n.namespace_ ().empty ())
    {
      this->NumberSizeClasses_.set (NumberSizeClasses_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "NucleationSites" && n.namespace_ ().empty ())
    {
      this->NucleationSites_.set (NucleationSites_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDPrecipitationDomain" && n.namespace_ ().empty ())
    {
      this->IDPrecipitationDomain_.set (IDPrecipitationDomain_traits::create (i, f, this));
      continue;
    }
  }
}

PrecipitationPhaseModel* PrecipitationPhaseModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PrecipitationPhaseModel (*this, f, c);
}

PrecipitationPhaseModel& PrecipitationPhaseModel::
operator= (const PrecipitationPhaseModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDCase_ = x.IDCase_;
    this->IDPhase_ = x.IDPhase_;
    this->NumberSizeClasses_ = x.NumberSizeClasses_;
    this->Name_ = x.Name_;
    this->NucleationSites_ = x.NucleationSites_;
    this->IDPrecipitationDomain_ = x.IDPrecipitationDomain_;
  }

  return *this;
}

PrecipitationPhaseModel::
~PrecipitationPhaseModel ()
{
}

bool
operator== (const PrecipitationPhaseModel& x, const PrecipitationPhaseModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDCase () == y.IDCase ()))
    return false;

  if (!(x.IDPhase () == y.IDPhase ()))
    return false;

  if (!(x.NumberSizeClasses () == y.NumberSizeClasses ()))
    return false;

  if (!(x.Name () == y.Name ()))
    return false;

  if (!(x.NucleationSites () == y.NucleationSites ()))
    return false;

  if (!(x.IDPrecipitationDomain () == y.IDPrecipitationDomain ()))
    return false;

  return true;
}

bool
operator!= (const PrecipitationPhaseModel& x, const PrecipitationPhaseModel& y)
{
  return !(x == y);
}

// ProjectModel
//

ProjectModel::
ProjectModel ()
: ::xml_schema::type (),
  Id_ (this),
  Name_ (this),
  APIName_ (this),
  External_APIName_ (this)
{
}

ProjectModel::
ProjectModel (const ProjectModel& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  Name_ (x.Name_, f, this),
  APIName_ (x.APIName_, f, this),
  External_APIName_ (x.External_APIName_, f, this)
{
}

ProjectModel::
ProjectModel (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  Name_ (this),
  APIName_ (this),
  External_APIName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ProjectModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "APIName" && n.namespace_ ().empty ())
    {
      this->APIName_.set (APIName_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "External_APIName" && n.namespace_ ().empty ())
    {
      this->External_APIName_.set (External_APIName_traits::create (i, f, this));
      continue;
    }
  }
}

ProjectModel* ProjectModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ProjectModel (*this, f, c);
}

ProjectModel& ProjectModel::
operator= (const ProjectModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->Name_ = x.Name_;
    this->APIName_ = x.APIName_;
    this->External_APIName_ = x.External_APIName_;
  }

  return *this;
}

ProjectModel::
~ProjectModel ()
{
}

bool
operator== (const ProjectModel& x, const ProjectModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.Name () == y.Name ()))
    return false;

  if (!(x.APIName () == y.APIName ()))
    return false;

  if (!(x.External_APIName () == y.External_APIName ()))
    return false;

  return true;
}

bool
operator!= (const ProjectModel& x, const ProjectModel& y)
{
  return !(x == y);
}

// ScheilConfigurationModel
//

ScheilConfigurationModel::
ScheilConfigurationModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDCase_ (this),
  StartTemperature_ (this),
  EndTemperature_ (this),
  StepSize_ (this),
  DependentPhase_ (this),
  MinimumLiquidFraction_ (this)
{
}

ScheilConfigurationModel::
ScheilConfigurationModel (const ScheilConfigurationModel& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDCase_ (x.IDCase_, f, this),
  StartTemperature_ (x.StartTemperature_, f, this),
  EndTemperature_ (x.EndTemperature_, f, this),
  StepSize_ (x.StepSize_, f, this),
  DependentPhase_ (x.DependentPhase_, f, this),
  MinimumLiquidFraction_ (x.MinimumLiquidFraction_, f, this)
{
}

ScheilConfigurationModel::
ScheilConfigurationModel (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDCase_ (this),
  StartTemperature_ (this),
  EndTemperature_ (this),
  StepSize_ (this),
  DependentPhase_ (this),
  MinimumLiquidFraction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ScheilConfigurationModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDCase" && n.namespace_ ().empty ())
    {
      this->IDCase_.set (IDCase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "StartTemperature" && n.namespace_ ().empty ())
    {
      this->StartTemperature_.set (StartTemperature_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "EndTemperature" && n.namespace_ ().empty ())
    {
      this->EndTemperature_.set (EndTemperature_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "StepSize" && n.namespace_ ().empty ())
    {
      this->StepSize_.set (StepSize_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "DependentPhase" && n.namespace_ ().empty ())
    {
      this->DependentPhase_.set (DependentPhase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MinimumLiquidFraction" && n.namespace_ ().empty ())
    {
      this->MinimumLiquidFraction_.set (MinimumLiquidFraction_traits::create (i, f, this));
      continue;
    }
  }
}

ScheilConfigurationModel* ScheilConfigurationModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ScheilConfigurationModel (*this, f, c);
}

ScheilConfigurationModel& ScheilConfigurationModel::
operator= (const ScheilConfigurationModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDCase_ = x.IDCase_;
    this->StartTemperature_ = x.StartTemperature_;
    this->EndTemperature_ = x.EndTemperature_;
    this->StepSize_ = x.StepSize_;
    this->DependentPhase_ = x.DependentPhase_;
    this->MinimumLiquidFraction_ = x.MinimumLiquidFraction_;
  }

  return *this;
}

ScheilConfigurationModel::
~ScheilConfigurationModel ()
{
}

bool
operator== (const ScheilConfigurationModel& x, const ScheilConfigurationModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDCase () == y.IDCase ()))
    return false;

  if (!(x.StartTemperature () == y.StartTemperature ()))
    return false;

  if (!(x.EndTemperature () == y.EndTemperature ()))
    return false;

  if (!(x.StepSize () == y.StepSize ()))
    return false;

  if (!(x.DependentPhase () == y.DependentPhase ()))
    return false;

  if (!(x.MinimumLiquidFraction () == y.MinimumLiquidFraction ()))
    return false;

  return true;
}

bool
operator!= (const ScheilConfigurationModel& x, const ScheilConfigurationModel& y)
{
  return !(x == y);
}

// ScheilCumulativeFractionModel
//

ScheilCumulativeFractionModel::
ScheilCumulativeFractionModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDCase_ (this),
  IDPhase_ (this),
  TypeComposition_ (this),
  Temperature_ (this),
  Value_ (this)
{
}

ScheilCumulativeFractionModel::
ScheilCumulativeFractionModel (const ScheilCumulativeFractionModel& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDCase_ (x.IDCase_, f, this),
  IDPhase_ (x.IDPhase_, f, this),
  TypeComposition_ (x.TypeComposition_, f, this),
  Temperature_ (x.Temperature_, f, this),
  Value_ (x.Value_, f, this)
{
}

ScheilCumulativeFractionModel::
ScheilCumulativeFractionModel (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDCase_ (this),
  IDPhase_ (this),
  TypeComposition_ (this),
  Temperature_ (this),
  Value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ScheilCumulativeFractionModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDCase" && n.namespace_ ().empty ())
    {
      this->IDCase_.set (IDCase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDPhase" && n.namespace_ ().empty ())
    {
      this->IDPhase_.set (IDPhase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "TypeComposition" && n.namespace_ ().empty ())
    {
      this->TypeComposition_.set (TypeComposition_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Temperature" && n.namespace_ ().empty ())
    {
      this->Temperature_.set (Temperature_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ScheilCumulativeFractionModel* ScheilCumulativeFractionModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ScheilCumulativeFractionModel (*this, f, c);
}

ScheilCumulativeFractionModel& ScheilCumulativeFractionModel::
operator= (const ScheilCumulativeFractionModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDCase_ = x.IDCase_;
    this->IDPhase_ = x.IDPhase_;
    this->TypeComposition_ = x.TypeComposition_;
    this->Temperature_ = x.Temperature_;
    this->Value_ = x.Value_;
  }

  return *this;
}

ScheilCumulativeFractionModel::
~ScheilCumulativeFractionModel ()
{
}

bool
operator== (const ScheilCumulativeFractionModel& x, const ScheilCumulativeFractionModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDCase () == y.IDCase ()))
    return false;

  if (!(x.IDPhase () == y.IDPhase ()))
    return false;

  if (!(x.TypeComposition () == y.TypeComposition ()))
    return false;

  if (!(x.Temperature () == y.Temperature ()))
    return false;

  if (!(x.Value () == y.Value ()))
    return false;

  return true;
}

bool
operator!= (const ScheilCumulativeFractionModel& x, const ScheilCumulativeFractionModel& y)
{
  return !(x == y);
}

// ScheilPhaseFractionModel
//

ScheilPhaseFractionModel::
ScheilPhaseFractionModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDCase_ (this),
  IDPhase_ (this),
  TypeComposition_ (this),
  Temperature_ (this),
  Value_ (this)
{
}

ScheilPhaseFractionModel::
ScheilPhaseFractionModel (const ScheilPhaseFractionModel& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDCase_ (x.IDCase_, f, this),
  IDPhase_ (x.IDPhase_, f, this),
  TypeComposition_ (x.TypeComposition_, f, this),
  Temperature_ (x.Temperature_, f, this),
  Value_ (x.Value_, f, this)
{
}

ScheilPhaseFractionModel::
ScheilPhaseFractionModel (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDCase_ (this),
  IDPhase_ (this),
  TypeComposition_ (this),
  Temperature_ (this),
  Value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ScheilPhaseFractionModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDCase" && n.namespace_ ().empty ())
    {
      this->IDCase_.set (IDCase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDPhase" && n.namespace_ ().empty ())
    {
      this->IDPhase_.set (IDPhase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "TypeComposition" && n.namespace_ ().empty ())
    {
      this->TypeComposition_.set (TypeComposition_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Temperature" && n.namespace_ ().empty ())
    {
      this->Temperature_.set (Temperature_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      this->Value_.set (Value_traits::create (i, f, this));
      continue;
    }
  }
}

ScheilPhaseFractionModel* ScheilPhaseFractionModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ScheilPhaseFractionModel (*this, f, c);
}

ScheilPhaseFractionModel& ScheilPhaseFractionModel::
operator= (const ScheilPhaseFractionModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDCase_ = x.IDCase_;
    this->IDPhase_ = x.IDPhase_;
    this->TypeComposition_ = x.TypeComposition_;
    this->Temperature_ = x.Temperature_;
    this->Value_ = x.Value_;
  }

  return *this;
}

ScheilPhaseFractionModel::
~ScheilPhaseFractionModel ()
{
}

bool
operator== (const ScheilPhaseFractionModel& x, const ScheilPhaseFractionModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDCase () == y.IDCase ()))
    return false;

  if (!(x.IDPhase () == y.IDPhase ()))
    return false;

  if (!(x.TypeComposition () == y.TypeComposition ()))
    return false;

  if (!(x.Temperature () == y.Temperature ()))
    return false;

  if (!(x.Value () == y.Value ()))
    return false;

  return true;
}

bool
operator!= (const ScheilPhaseFractionModel& x, const ScheilPhaseFractionModel& y)
{
  return !(x == y);
}

// SelectedElementsModel
//

SelectedElementsModel::
SelectedElementsModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDProject_ (this),
  IDElement_ (this),
  IsReferenceElement_ (this)
{
}

SelectedElementsModel::
SelectedElementsModel (const SelectedElementsModel& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDProject_ (x.IDProject_, f, this),
  IDElement_ (x.IDElement_, f, this),
  IsReferenceElement_ (x.IsReferenceElement_, f, this)
{
}

SelectedElementsModel::
SelectedElementsModel (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDProject_ (this),
  IDElement_ (this),
  IsReferenceElement_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void SelectedElementsModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDProject" && n.namespace_ ().empty ())
    {
      this->IDProject_.set (IDProject_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDElement" && n.namespace_ ().empty ())
    {
      this->IDElement_.set (IDElement_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IsReferenceElement" && n.namespace_ ().empty ())
    {
      this->IsReferenceElement_.set (IsReferenceElement_traits::create (i, f, this));
      continue;
    }
  }
}

SelectedElementsModel* SelectedElementsModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SelectedElementsModel (*this, f, c);
}

SelectedElementsModel& SelectedElementsModel::
operator= (const SelectedElementsModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDProject_ = x.IDProject_;
    this->IDElement_ = x.IDElement_;
    this->IsReferenceElement_ = x.IsReferenceElement_;
  }

  return *this;
}

SelectedElementsModel::
~SelectedElementsModel ()
{
}

bool
operator== (const SelectedElementsModel& x, const SelectedElementsModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDProject () == y.IDProject ()))
    return false;

  if (!(x.IDElement () == y.IDElement ()))
    return false;

  if (!(x.IsReferenceElement () == y.IsReferenceElement ()))
    return false;

  return true;
}

bool
operator!= (const SelectedElementsModel& x, const SelectedElementsModel& y)
{
  return !(x == y);
}

// SelectedPhasesModel
//

SelectedPhasesModel::
SelectedPhasesModel ()
: ::xml_schema::type (),
  Id_ (this),
  IDCase_ (this),
  IDPhase_ (this)
{
}

SelectedPhasesModel::
SelectedPhasesModel (const SelectedPhasesModel& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Id_ (x.Id_, f, this),
  IDCase_ (x.IDCase_, f, this),
  IDPhase_ (x.IDPhase_, f, this)
{
}

SelectedPhasesModel::
SelectedPhasesModel (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Id_ (this),
  IDCase_ (this),
  IDPhase_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void SelectedPhasesModel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Id" && n.namespace_ ().empty ())
    {
      this->Id_.set (Id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDCase" && n.namespace_ ().empty ())
    {
      this->IDCase_.set (IDCase_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "IDPhase" && n.namespace_ ().empty ())
    {
      this->IDPhase_.set (IDPhase_traits::create (i, f, this));
      continue;
    }
  }
}

SelectedPhasesModel* SelectedPhasesModel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SelectedPhasesModel (*this, f, c);
}

SelectedPhasesModel& SelectedPhasesModel::
operator= (const SelectedPhasesModel& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Id_ = x.Id_;
    this->IDCase_ = x.IDCase_;
    this->IDPhase_ = x.IDPhase_;
  }

  return *this;
}

SelectedPhasesModel::
~SelectedPhasesModel ()
{
}

bool
operator== (const SelectedPhasesModel& x, const SelectedPhasesModel& y)
{
  if (!(x.Id () == y.Id ()))
    return false;

  if (!(x.IDCase () == y.IDCase ()))
    return false;

  if (!(x.IDPhase () == y.IDPhase ()))
    return false;

  return true;
}

bool
operator!= (const SelectedPhasesModel& x, const SelectedPhasesModel& y)
{
  return !(x == y);
}

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, const ActivePhasesModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDProject ())
  {
    o << ::std::endl << "IDProject: " << *i.IDProject ();
  }

  if (i.IDPhase ())
  {
    o << ::std::endl << "IDPhase: " << *i.IDPhase ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ActivePhasesConfigurationModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDProject ())
  {
    o << ::std::endl << "IDProject: " << *i.IDProject ();
  }

  if (i.StartTemp ())
  {
    o << ::std::endl << "StartTemp: " << *i.StartTemp ();
  }

  if (i.EndTemp ())
  {
    o << ::std::endl << "EndTemp: " << *i.EndTemp ();
  }

  if (i.StepSize ())
  {
    o << ::std::endl << "StepSize: " << *i.StepSize ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ActivePhasesElementCompositionModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDProject ())
  {
    o << ::std::endl << "IDProject: " << *i.IDProject ();
  }

  if (i.IDElement ())
  {
    o << ::std::endl << "IDElement: " << *i.IDElement ();
  }

  if (i.Value ())
  {
    o << ::std::endl << "Value: " << *i.Value ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const CALPHADDatabaseModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDProject ())
  {
    o << ::std::endl << "IDProject: " << *i.IDProject ();
  }

  if (i.Thermodynamic ())
  {
    o << ::std::endl << "Thermodynamic: " << *i.Thermodynamic ();
  }

  if (i.Physical ())
  {
    o << ::std::endl << "Physical: " << *i.Physical ();
  }

  if (i.Mobility ())
  {
    o << ::std::endl << "Mobility: " << *i.Mobility ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const CaseModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDProject ())
  {
    o << ::std::endl << "IDProject: " << *i.IDProject ();
  }

  if (i.IDGroup ())
  {
    o << ::std::endl << "IDGroup: " << *i.IDGroup ();
  }

  if (i.Name ())
  {
    o << ::std::endl << "Name: " << *i.Name ();
  }

  if (i.Script ())
  {
    o << ::std::endl << "Script: " << *i.Script ();
  }

  if (i.Date ())
  {
    o << ::std::endl << "Date: " << *i.Date ();
  }

  if (i.PosX ())
  {
    o << ::std::endl << "PosX: " << *i.PosX ();
  }

  if (i.PosY ())
  {
    o << ::std::endl << "PosY: " << *i.PosY ();
  }

  if (i.PosZ ())
  {
    o << ::std::endl << "PosZ: " << *i.PosZ ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ElementModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.Name ())
  {
    o << ::std::endl << "Name: " << *i.Name ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ElementCompositionModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDCase ())
  {
    o << ::std::endl << "IDCase: " << *i.IDCase ();
  }

  if (i.IDElement ())
  {
    o << ::std::endl << "IDElement: " << *i.IDElement ();
  }

  if (i.TypeComposition ())
  {
    o << ::std::endl << "TypeComposition: " << *i.TypeComposition ();
  }

  if (i.Value ())
  {
    o << ::std::endl << "Value: " << *i.Value ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const EquilibriumConfigurationModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDCase ())
  {
    o << ::std::endl << "IDCase: " << *i.IDCase ();
  }

  if (i.Temperature ())
  {
    o << ::std::endl << "Temperature: " << *i.Temperature ();
  }

  if (i.StartTemperature ())
  {
    o << ::std::endl << "StartTemperature: " << *i.StartTemperature ();
  }

  if (i.EndTemperature ())
  {
    o << ::std::endl << "EndTemperature: " << *i.EndTemperature ();
  }

  if (i.TemperatureType ())
  {
    o << ::std::endl << "TemperatureType: " << *i.TemperatureType ();
  }

  if (i.StepSize ())
  {
    o << ::std::endl << "StepSize: " << *i.StepSize ();
  }

  if (i.Pressure ())
  {
    o << ::std::endl << "Pressure: " << *i.Pressure ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const EquilibriumPhaseFractionModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDCase ())
  {
    o << ::std::endl << "IDCase: " << *i.IDCase ();
  }

  if (i.Temperature ())
  {
    o << ::std::endl << "Temperature: " << *i.Temperature ();
  }

  if (i.Value ())
  {
    o << ::std::endl << "Value: " << *i.Value ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const HeatTreatmentModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDCase ())
  {
    o << ::std::endl << "IDCase: " << *i.IDCase ();
  }

  if (i.Name ())
  {
    o << ::std::endl << "Name: " << *i.Name ();
  }

  if (i.MaxTemperatureStep ())
  {
    o << ::std::endl << "MaxTemperatureStep: " << *i.MaxTemperatureStep ();
  }

  if (i.IDPrecipitationDomain ())
  {
    o << ::std::endl << "IDPrecipitationDomain: " << *i.IDPrecipitationDomain ();
  }

  if (i.StartTemperature ())
  {
    o << ::std::endl << "StartTemperature: " << *i.StartTemperature ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const HeatTreatmentProfileModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDHeatTreatment ())
  {
    o << ::std::endl << "IDHeatTreatment: " << *i.IDHeatTreatment ();
  }

  if (i.Time ())
  {
    o << ::std::endl << "Time: " << *i.Time ();
  }

  if (i.Temperature ())
  {
    o << ::std::endl << "Temperature: " << *i.Temperature ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const HeatTreatmentSegmentModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.StepIndex ())
  {
    o << ::std::endl << "StepIndex: " << *i.StepIndex ();
  }

  if (i.IDHeatTreatment ())
  {
    o << ::std::endl << "IDHeatTreatment: " << *i.IDHeatTreatment ();
  }

  if (i.IDPrecipitationDomain ())
  {
    o << ::std::endl << "IDPrecipitationDomain: " << *i.IDPrecipitationDomain ();
  }

  if (i.EndTemperature ())
  {
    o << ::std::endl << "EndTemperature: " << *i.EndTemperature ();
  }

  if (i.TemperatureGradient ())
  {
    o << ::std::endl << "TemperatureGradient: " << *i.TemperatureGradient ();
  }

  if (i.Duration ())
  {
    o << ::std::endl << "Duration: " << *i.Duration ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const PhaseModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.Name ())
  {
    o << ::std::endl << "Name: " << *i.Name ();
  }

  if (i.DBType ())
  {
    o << ::std::endl << "DBType: " << *i.DBType ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const PrecipitationSimulationDataModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDPrecipitationPhase ())
  {
    o << ::std::endl << "IDPrecipitationPhase: " << *i.IDPrecipitationPhase ();
  }

  if (i.IDHeatTreatment ())
  {
    o << ::std::endl << "IDHeatTreatment: " << *i.IDHeatTreatment ();
  }

  if (i.Time ())
  {
    o << ::std::endl << "Time: " << *i.Time ();
  }

  if (i.PhaseFraction ())
  {
    o << ::std::endl << "PhaseFraction: " << *i.PhaseFraction ();
  }

  if (i.NumberDensity ())
  {
    o << ::std::endl << "NumberDensity: " << *i.NumberDensity ();
  }

  if (i.MeanRadius ())
  {
    o << ::std::endl << "MeanRadius: " << *i.MeanRadius ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const PrecipitationDomainModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDCase ())
  {
    o << ::std::endl << "IDCase: " << *i.IDCase ();
  }

  if (i.Name ())
  {
    o << ::std::endl << "Name: " << *i.Name ();
  }

  if (i.IDPhase ())
  {
    o << ::std::endl << "IDPhase: " << *i.IDPhase ();
  }

  if (i.InitialGrainDiameter ())
  {
    o << ::std::endl << "InitialGrainDiameter: " << *i.InitialGrainDiameter ();
  }

  if (i.EquilibriumDiDe ())
  {
    o << ::std::endl << "EquilibriumDiDe: " << *i.EquilibriumDiDe ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const PrecipitationPhaseModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDCase ())
  {
    o << ::std::endl << "IDCase: " << *i.IDCase ();
  }

  if (i.IDPhase ())
  {
    o << ::std::endl << "IDPhase: " << *i.IDPhase ();
  }

  if (i.NumberSizeClasses ())
  {
    o << ::std::endl << "NumberSizeClasses: " << *i.NumberSizeClasses ();
  }

  if (i.Name ())
  {
    o << ::std::endl << "Name: " << *i.Name ();
  }

  if (i.NucleationSites ())
  {
    o << ::std::endl << "NucleationSites: " << *i.NucleationSites ();
  }

  if (i.IDPrecipitationDomain ())
  {
    o << ::std::endl << "IDPrecipitationDomain: " << *i.IDPrecipitationDomain ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ProjectModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.Name ())
  {
    o << ::std::endl << "Name: " << *i.Name ();
  }

  if (i.APIName ())
  {
    o << ::std::endl << "APIName: " << *i.APIName ();
  }

  if (i.External_APIName ())
  {
    o << ::std::endl << "External_APIName: " << *i.External_APIName ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ScheilConfigurationModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDCase ())
  {
    o << ::std::endl << "IDCase: " << *i.IDCase ();
  }

  if (i.StartTemperature ())
  {
    o << ::std::endl << "StartTemperature: " << *i.StartTemperature ();
  }

  if (i.EndTemperature ())
  {
    o << ::std::endl << "EndTemperature: " << *i.EndTemperature ();
  }

  if (i.StepSize ())
  {
    o << ::std::endl << "StepSize: " << *i.StepSize ();
  }

  if (i.DependentPhase ())
  {
    o << ::std::endl << "DependentPhase: " << *i.DependentPhase ();
  }

  if (i.MinimumLiquidFraction ())
  {
    o << ::std::endl << "MinimumLiquidFraction: " << *i.MinimumLiquidFraction ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ScheilCumulativeFractionModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDCase ())
  {
    o << ::std::endl << "IDCase: " << *i.IDCase ();
  }

  if (i.IDPhase ())
  {
    o << ::std::endl << "IDPhase: " << *i.IDPhase ();
  }

  if (i.TypeComposition ())
  {
    o << ::std::endl << "TypeComposition: " << *i.TypeComposition ();
  }

  if (i.Temperature ())
  {
    o << ::std::endl << "Temperature: " << *i.Temperature ();
  }

  if (i.Value ())
  {
    o << ::std::endl << "Value: " << *i.Value ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ScheilPhaseFractionModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDCase ())
  {
    o << ::std::endl << "IDCase: " << *i.IDCase ();
  }

  if (i.IDPhase ())
  {
    o << ::std::endl << "IDPhase: " << *i.IDPhase ();
  }

  if (i.TypeComposition ())
  {
    o << ::std::endl << "TypeComposition: " << *i.TypeComposition ();
  }

  if (i.Temperature ())
  {
    o << ::std::endl << "Temperature: " << *i.Temperature ();
  }

  if (i.Value ())
  {
    o << ::std::endl << "Value: " << *i.Value ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const SelectedElementsModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDProject ())
  {
    o << ::std::endl << "IDProject: " << *i.IDProject ();
  }

  if (i.IDElement ())
  {
    o << ::std::endl << "IDElement: " << *i.IDElement ();
  }

  if (i.IsReferenceElement ())
  {
    o << ::std::endl << "IsReferenceElement: " << *i.IsReferenceElement ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const SelectedPhasesModel& i)
{
  if (i.Id ())
  {
    o << ::std::endl << "Id: " << *i.Id ();
  }

  if (i.IDCase ())
  {
    o << ::std::endl << "IDCase: " << *i.IDCase ();
  }

  if (i.IDPhase ())
  {
    o << ::std::endl << "IDPhase: " << *i.IDPhase ();
  }

  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const ActivePhasesModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDProject
  //
  if (i.IDProject ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDProject",
        e));

    a << *i.IDProject ();
  }

  // IDPhase
  //
  if (i.IDPhase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDPhase",
        e));

    a << *i.IDPhase ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ActivePhasesConfigurationModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDProject
  //
  if (i.IDProject ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDProject",
        e));

    a << *i.IDProject ();
  }

  // StartTemp
  //
  if (i.StartTemp ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "StartTemp",
        e));

    a << ::xml_schema::as_double(*i.StartTemp ());
  }

  // EndTemp
  //
  if (i.EndTemp ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "EndTemp",
        e));

    a << ::xml_schema::as_double(*i.EndTemp ());
  }

  // StepSize
  //
  if (i.StepSize ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "StepSize",
        e));

    a << ::xml_schema::as_double(*i.StepSize ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const ActivePhasesElementCompositionModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDProject
  //
  if (i.IDProject ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDProject",
        e));

    a << *i.IDProject ();
  }

  // IDElement
  //
  if (i.IDElement ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDElement",
        e));

    a << *i.IDElement ();
  }

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << ::xml_schema::as_double(*i.Value ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const CALPHADDatabaseModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDProject
  //
  if (i.IDProject ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDProject",
        e));

    a << *i.IDProject ();
  }

  // Thermodynamic
  //
  if (i.Thermodynamic ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Thermodynamic",
        e));

    a << *i.Thermodynamic ();
  }

  // Physical
  //
  if (i.Physical ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Physical",
        e));

    a << *i.Physical ();
  }

  // Mobility
  //
  if (i.Mobility ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Mobility",
        e));

    a << *i.Mobility ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const CaseModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDProject
  //
  if (i.IDProject ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDProject",
        e));

    a << *i.IDProject ();
  }

  // IDGroup
  //
  if (i.IDGroup ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDGroup",
        e));

    a << *i.IDGroup ();
  }

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << *i.Name ();
  }

  // Script
  //
  if (i.Script ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Script",
        e));

    a << *i.Script ();
  }

  // Date
  //
  if (i.Date ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Date",
        e));

    a << *i.Date ();
  }

  // PosX
  //
  if (i.PosX ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "PosX",
        e));

    a << ::xml_schema::as_double(*i.PosX ());
  }

  // PosY
  //
  if (i.PosY ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "PosY",
        e));

    a << ::xml_schema::as_double(*i.PosY ());
  }

  // PosZ
  //
  if (i.PosZ ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "PosZ",
        e));

    a << ::xml_schema::as_double(*i.PosZ ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const ElementModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << *i.Name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ElementCompositionModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDCase
  //
  if (i.IDCase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDCase",
        e));

    a << *i.IDCase ();
  }

  // IDElement
  //
  if (i.IDElement ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDElement",
        e));

    a << *i.IDElement ();
  }

  // TypeComposition
  //
  if (i.TypeComposition ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "TypeComposition",
        e));

    a << *i.TypeComposition ();
  }

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << ::xml_schema::as_double(*i.Value ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const EquilibriumConfigurationModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDCase
  //
  if (i.IDCase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDCase",
        e));

    a << *i.IDCase ();
  }

  // Temperature
  //
  if (i.Temperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Temperature",
        e));

    a << ::xml_schema::as_double(*i.Temperature ());
  }

  // StartTemperature
  //
  if (i.StartTemperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "StartTemperature",
        e));

    a << ::xml_schema::as_double(*i.StartTemperature ());
  }

  // EndTemperature
  //
  if (i.EndTemperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "EndTemperature",
        e));

    a << ::xml_schema::as_double(*i.EndTemperature ());
  }

  // TemperatureType
  //
  if (i.TemperatureType ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "TemperatureType",
        e));

    a << *i.TemperatureType ();
  }

  // StepSize
  //
  if (i.StepSize ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "StepSize",
        e));

    a << ::xml_schema::as_double(*i.StepSize ());
  }

  // Pressure
  //
  if (i.Pressure ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Pressure",
        e));

    a << ::xml_schema::as_double(*i.Pressure ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const EquilibriumPhaseFractionModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDCase
  //
  if (i.IDCase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDCase",
        e));

    a << *i.IDCase ();
  }

  // Temperature
  //
  if (i.Temperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Temperature",
        e));

    a << ::xml_schema::as_double(*i.Temperature ());
  }

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << ::xml_schema::as_double(*i.Value ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const HeatTreatmentModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDCase
  //
  if (i.IDCase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDCase",
        e));

    a << *i.IDCase ();
  }

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << ::xml_schema::as_double(*i.Name ());
  }

  // MaxTemperatureStep
  //
  if (i.MaxTemperatureStep ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "MaxTemperatureStep",
        e));

    a << *i.MaxTemperatureStep ();
  }

  // IDPrecipitationDomain
  //
  if (i.IDPrecipitationDomain ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDPrecipitationDomain",
        e));

    a << *i.IDPrecipitationDomain ();
  }

  // StartTemperature
  //
  if (i.StartTemperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "StartTemperature",
        e));

    a << ::xml_schema::as_double(*i.StartTemperature ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const HeatTreatmentProfileModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDHeatTreatment
  //
  if (i.IDHeatTreatment ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDHeatTreatment",
        e));

    a << *i.IDHeatTreatment ();
  }

  // Time
  //
  if (i.Time ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Time",
        e));

    a << ::xml_schema::as_double(*i.Time ());
  }

  // Temperature
  //
  if (i.Temperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Temperature",
        e));

    a << ::xml_schema::as_double(*i.Temperature ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const HeatTreatmentSegmentModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // StepIndex
  //
  if (i.StepIndex ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "StepIndex",
        e));

    a << *i.StepIndex ();
  }

  // IDHeatTreatment
  //
  if (i.IDHeatTreatment ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDHeatTreatment",
        e));

    a << *i.IDHeatTreatment ();
  }

  // IDPrecipitationDomain
  //
  if (i.IDPrecipitationDomain ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDPrecipitationDomain",
        e));

    a << *i.IDPrecipitationDomain ();
  }

  // EndTemperature
  //
  if (i.EndTemperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "EndTemperature",
        e));

    a << ::xml_schema::as_double(*i.EndTemperature ());
  }

  // TemperatureGradient
  //
  if (i.TemperatureGradient ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "TemperatureGradient",
        e));

    a << ::xml_schema::as_double(*i.TemperatureGradient ());
  }

  // Duration
  //
  if (i.Duration ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Duration",
        e));

    a << ::xml_schema::as_double(*i.Duration ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const PhaseModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << *i.Name ();
  }

  // DBType
  //
  if (i.DBType ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "DBType",
        e));

    a << *i.DBType ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const PrecipitationSimulationDataModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDPrecipitationPhase
  //
  if (i.IDPrecipitationPhase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDPrecipitationPhase",
        e));

    a << *i.IDPrecipitationPhase ();
  }

  // IDHeatTreatment
  //
  if (i.IDHeatTreatment ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDHeatTreatment",
        e));

    a << *i.IDHeatTreatment ();
  }

  // Time
  //
  if (i.Time ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Time",
        e));

    a << ::xml_schema::as_double(*i.Time ());
  }

  // PhaseFraction
  //
  if (i.PhaseFraction ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "PhaseFraction",
        e));

    a << ::xml_schema::as_double(*i.PhaseFraction ());
  }

  // NumberDensity
  //
  if (i.NumberDensity ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "NumberDensity",
        e));

    a << ::xml_schema::as_double(*i.NumberDensity ());
  }

  // MeanRadius
  //
  if (i.MeanRadius ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "MeanRadius",
        e));

    a << ::xml_schema::as_double(*i.MeanRadius ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const PrecipitationDomainModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDCase
  //
  if (i.IDCase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDCase",
        e));

    a << *i.IDCase ();
  }

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << *i.Name ();
  }

  // IDPhase
  //
  if (i.IDPhase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDPhase",
        e));

    a << *i.IDPhase ();
  }

  // InitialGrainDiameter
  //
  if (i.InitialGrainDiameter ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "InitialGrainDiameter",
        e));

    a << ::xml_schema::as_double(*i.InitialGrainDiameter ());
  }

  // EquilibriumDiDe
  //
  if (i.EquilibriumDiDe ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "EquilibriumDiDe",
        e));

    a << ::xml_schema::as_double(*i.EquilibriumDiDe ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const PrecipitationPhaseModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDCase
  //
  if (i.IDCase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDCase",
        e));

    a << *i.IDCase ();
  }

  // IDPhase
  //
  if (i.IDPhase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDPhase",
        e));

    a << *i.IDPhase ();
  }

  // NumberSizeClasses
  //
  if (i.NumberSizeClasses ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "NumberSizeClasses",
        e));

    a << *i.NumberSizeClasses ();
  }

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << *i.Name ();
  }

  // NucleationSites
  //
  if (i.NucleationSites ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "NucleationSites",
        e));

    a << *i.NucleationSites ();
  }

  // IDPrecipitationDomain
  //
  if (i.IDPrecipitationDomain ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDPrecipitationDomain",
        e));

    a << *i.IDPrecipitationDomain ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ProjectModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // Name
  //
  if (i.Name ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << *i.Name ();
  }

  // APIName
  //
  if (i.APIName ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "APIName",
        e));

    a << *i.APIName ();
  }

  // External_APIName
  //
  if (i.External_APIName ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "External_APIName",
        e));

    a << *i.External_APIName ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ScheilConfigurationModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDCase
  //
  if (i.IDCase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDCase",
        e));

    a << *i.IDCase ();
  }

  // StartTemperature
  //
  if (i.StartTemperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "StartTemperature",
        e));

    a << ::xml_schema::as_double(*i.StartTemperature ());
  }

  // EndTemperature
  //
  if (i.EndTemperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "EndTemperature",
        e));

    a << ::xml_schema::as_double(*i.EndTemperature ());
  }

  // StepSize
  //
  if (i.StepSize ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "StepSize",
        e));

    a << ::xml_schema::as_double(*i.StepSize ());
  }

  // DependentPhase
  //
  if (i.DependentPhase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "DependentPhase",
        e));

    a << *i.DependentPhase ();
  }

  // MinimumLiquidFraction
  //
  if (i.MinimumLiquidFraction ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "MinimumLiquidFraction",
        e));

    a << ::xml_schema::as_double(*i.MinimumLiquidFraction ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const ScheilCumulativeFractionModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDCase
  //
  if (i.IDCase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDCase",
        e));

    a << *i.IDCase ();
  }

  // IDPhase
  //
  if (i.IDPhase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDPhase",
        e));

    a << ::xml_schema::as_double(*i.IDPhase ());
  }

  // TypeComposition
  //
  if (i.TypeComposition ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "TypeComposition",
        e));

    a << *i.TypeComposition ();
  }

  // Temperature
  //
  if (i.Temperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Temperature",
        e));

    a << ::xml_schema::as_double(*i.Temperature ());
  }

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << ::xml_schema::as_double(*i.Value ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const ScheilPhaseFractionModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDCase
  //
  if (i.IDCase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDCase",
        e));

    a << *i.IDCase ();
  }

  // IDPhase
  //
  if (i.IDPhase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDPhase",
        e));

    a << ::xml_schema::as_double(*i.IDPhase ());
  }

  // TypeComposition
  //
  if (i.TypeComposition ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "TypeComposition",
        e));

    a << *i.TypeComposition ();
  }

  // Temperature
  //
  if (i.Temperature ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Temperature",
        e));

    a << ::xml_schema::as_double(*i.Temperature ());
  }

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Value",
        e));

    a << ::xml_schema::as_double(*i.Value ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const SelectedElementsModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDProject
  //
  if (i.IDProject ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDProject",
        e));

    a << *i.IDProject ();
  }

  // IDElement
  //
  if (i.IDElement ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDElement",
        e));

    a << *i.IDElement ();
  }

  // IsReferenceElement
  //
  if (i.IsReferenceElement ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IsReferenceElement",
        e));

    a << *i.IsReferenceElement ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const SelectedPhasesModel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Id
  //
  if (i.Id ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Id",
        e));

    a << *i.Id ();
  }

  // IDCase
  //
  if (i.IDCase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDCase",
        e));

    a << *i.IDCase ();
  }

  // IDPhase
  //
  if (i.IDPhase ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "IDPhase",
        e));

    a << *i.IDPhase ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

