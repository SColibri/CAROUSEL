// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef C__USERS_DROGO_DOCUMENTS_TUM_THESIS_FRAMEWORK_AMFRAMEWORK_CODE_AMCORE_AMMODELS_MODEL_SCHEMA_H
#define C__USERS_DROGO_DOCUMENTS_TUM_THESIS_FRAMEWORK_AMFRAMEWORK_CODE_AMCORE_AMMODELS_MODEL_SCHEMA_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class ActivePhasesModel;
class ActivePhasesConfigurationModel;
class ActivePhasesElementCompositionModel;
class CALPHADDatabaseModel;
class CaseModel;
class ElementModel;
class ElementCompositionModel;
class EquilibriumConfigurationModel;
class EquilibriumPhaseFractionModel;
class HeatTreatmentModel;
class HeatTreatmentProfileModel;
class HeatTreatmentSegmentModel;
class PhaseModel;
class PrecipitationSimulationDataModel;
class PrecipitationDomainModel;
class PrecipitationPhaseModel;
class ProjectModel;
class ScheilConfigurationModel;
class ScheilCumulativeFractionModel;
class ScheilPhaseFractionModel;
class SelectedElementsModel;
class SelectedPhasesModel;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class ActivePhasesModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDProject
  //
  typedef ::xml_schema::int_ IDProject_type;
  typedef ::xsd::cxx::tree::optional< IDProject_type > IDProject_optional;
  typedef ::xsd::cxx::tree::traits< IDProject_type, char > IDProject_traits;

  const IDProject_optional&
  IDProject () const;

  IDProject_optional&
  IDProject ();

  void
  IDProject (const IDProject_type& x);

  void
  IDProject (const IDProject_optional& x);

  // IDPhase
  //
  typedef ::xml_schema::int_ IDPhase_type;
  typedef ::xsd::cxx::tree::optional< IDPhase_type > IDPhase_optional;
  typedef ::xsd::cxx::tree::traits< IDPhase_type, char > IDPhase_traits;

  const IDPhase_optional&
  IDPhase () const;

  IDPhase_optional&
  IDPhase ();

  void
  IDPhase (const IDPhase_type& x);

  void
  IDPhase (const IDPhase_optional& x);

  // Constructors.
  //
  ActivePhasesModel ();

  ActivePhasesModel (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ActivePhasesModel (const ActivePhasesModel& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual ActivePhasesModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ActivePhasesModel&
  operator= (const ActivePhasesModel& x);

  virtual 
  ~ActivePhasesModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDProject_optional IDProject_;
  IDPhase_optional IDPhase_;
};

bool
operator== (const ActivePhasesModel&, const ActivePhasesModel&);

bool
operator!= (const ActivePhasesModel&, const ActivePhasesModel&);


class ActivePhasesConfigurationModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDProject
  //
  typedef ::xml_schema::int_ IDProject_type;
  typedef ::xsd::cxx::tree::optional< IDProject_type > IDProject_optional;
  typedef ::xsd::cxx::tree::traits< IDProject_type, char > IDProject_traits;

  const IDProject_optional&
  IDProject () const;

  IDProject_optional&
  IDProject ();

  void
  IDProject (const IDProject_type& x);

  void
  IDProject (const IDProject_optional& x);

  // StartTemp
  //
  typedef ::xml_schema::double_ StartTemp_type;
  typedef ::xsd::cxx::tree::optional< StartTemp_type > StartTemp_optional;
  typedef ::xsd::cxx::tree::traits< StartTemp_type, char, ::xsd::cxx::tree::schema_type::double_ > StartTemp_traits;

  const StartTemp_optional&
  StartTemp () const;

  StartTemp_optional&
  StartTemp ();

  void
  StartTemp (const StartTemp_type& x);

  void
  StartTemp (const StartTemp_optional& x);

  // EndTemp
  //
  typedef ::xml_schema::double_ EndTemp_type;
  typedef ::xsd::cxx::tree::optional< EndTemp_type > EndTemp_optional;
  typedef ::xsd::cxx::tree::traits< EndTemp_type, char, ::xsd::cxx::tree::schema_type::double_ > EndTemp_traits;

  const EndTemp_optional&
  EndTemp () const;

  EndTemp_optional&
  EndTemp ();

  void
  EndTemp (const EndTemp_type& x);

  void
  EndTemp (const EndTemp_optional& x);

  // StepSize
  //
  typedef ::xml_schema::double_ StepSize_type;
  typedef ::xsd::cxx::tree::optional< StepSize_type > StepSize_optional;
  typedef ::xsd::cxx::tree::traits< StepSize_type, char, ::xsd::cxx::tree::schema_type::double_ > StepSize_traits;

  const StepSize_optional&
  StepSize () const;

  StepSize_optional&
  StepSize ();

  void
  StepSize (const StepSize_type& x);

  void
  StepSize (const StepSize_optional& x);

  // Constructors.
  //
  ActivePhasesConfigurationModel ();

  ActivePhasesConfigurationModel (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  ActivePhasesConfigurationModel (const ActivePhasesConfigurationModel& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

  virtual ActivePhasesConfigurationModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ActivePhasesConfigurationModel&
  operator= (const ActivePhasesConfigurationModel& x);

  virtual 
  ~ActivePhasesConfigurationModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDProject_optional IDProject_;
  StartTemp_optional StartTemp_;
  EndTemp_optional EndTemp_;
  StepSize_optional StepSize_;
};

bool
operator== (const ActivePhasesConfigurationModel&, const ActivePhasesConfigurationModel&);

bool
operator!= (const ActivePhasesConfigurationModel&, const ActivePhasesConfigurationModel&);


class ActivePhasesElementCompositionModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDProject
  //
  typedef ::xml_schema::int_ IDProject_type;
  typedef ::xsd::cxx::tree::optional< IDProject_type > IDProject_optional;
  typedef ::xsd::cxx::tree::traits< IDProject_type, char > IDProject_traits;

  const IDProject_optional&
  IDProject () const;

  IDProject_optional&
  IDProject ();

  void
  IDProject (const IDProject_type& x);

  void
  IDProject (const IDProject_optional& x);

  // IDElement
  //
  typedef ::xml_schema::int_ IDElement_type;
  typedef ::xsd::cxx::tree::optional< IDElement_type > IDElement_optional;
  typedef ::xsd::cxx::tree::traits< IDElement_type, char > IDElement_traits;

  const IDElement_optional&
  IDElement () const;

  IDElement_optional&
  IDElement ();

  void
  IDElement (const IDElement_type& x);

  void
  IDElement (const IDElement_optional& x);

  // Value
  //
  typedef ::xml_schema::double_ Value_type;
  typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
  typedef ::xsd::cxx::tree::traits< Value_type, char, ::xsd::cxx::tree::schema_type::double_ > Value_traits;

  const Value_optional&
  Value () const;

  Value_optional&
  Value ();

  void
  Value (const Value_type& x);

  void
  Value (const Value_optional& x);

  // Constructors.
  //
  ActivePhasesElementCompositionModel ();

  ActivePhasesElementCompositionModel (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  ActivePhasesElementCompositionModel (const ActivePhasesElementCompositionModel& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual ActivePhasesElementCompositionModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ActivePhasesElementCompositionModel&
  operator= (const ActivePhasesElementCompositionModel& x);

  virtual 
  ~ActivePhasesElementCompositionModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDProject_optional IDProject_;
  IDElement_optional IDElement_;
  Value_optional Value_;
};

bool
operator== (const ActivePhasesElementCompositionModel&, const ActivePhasesElementCompositionModel&);

bool
operator!= (const ActivePhasesElementCompositionModel&, const ActivePhasesElementCompositionModel&);


class CALPHADDatabaseModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDProject
  //
  typedef ::xml_schema::int_ IDProject_type;
  typedef ::xsd::cxx::tree::optional< IDProject_type > IDProject_optional;
  typedef ::xsd::cxx::tree::traits< IDProject_type, char > IDProject_traits;

  const IDProject_optional&
  IDProject () const;

  IDProject_optional&
  IDProject ();

  void
  IDProject (const IDProject_type& x);

  void
  IDProject (const IDProject_optional& x);

  // Thermodynamic
  //
  typedef ::xml_schema::string Thermodynamic_type;
  typedef ::xsd::cxx::tree::optional< Thermodynamic_type > Thermodynamic_optional;
  typedef ::xsd::cxx::tree::traits< Thermodynamic_type, char > Thermodynamic_traits;

  const Thermodynamic_optional&
  Thermodynamic () const;

  Thermodynamic_optional&
  Thermodynamic ();

  void
  Thermodynamic (const Thermodynamic_type& x);

  void
  Thermodynamic (const Thermodynamic_optional& x);

  void
  Thermodynamic (::std::unique_ptr< Thermodynamic_type > p);

  // Physical
  //
  typedef ::xml_schema::string Physical_type;
  typedef ::xsd::cxx::tree::optional< Physical_type > Physical_optional;
  typedef ::xsd::cxx::tree::traits< Physical_type, char > Physical_traits;

  const Physical_optional&
  Physical () const;

  Physical_optional&
  Physical ();

  void
  Physical (const Physical_type& x);

  void
  Physical (const Physical_optional& x);

  void
  Physical (::std::unique_ptr< Physical_type > p);

  // Mobility
  //
  typedef ::xml_schema::string Mobility_type;
  typedef ::xsd::cxx::tree::optional< Mobility_type > Mobility_optional;
  typedef ::xsd::cxx::tree::traits< Mobility_type, char > Mobility_traits;

  const Mobility_optional&
  Mobility () const;

  Mobility_optional&
  Mobility ();

  void
  Mobility (const Mobility_type& x);

  void
  Mobility (const Mobility_optional& x);

  void
  Mobility (::std::unique_ptr< Mobility_type > p);

  // Constructors.
  //
  CALPHADDatabaseModel ();

  CALPHADDatabaseModel (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  CALPHADDatabaseModel (const CALPHADDatabaseModel& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual CALPHADDatabaseModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CALPHADDatabaseModel&
  operator= (const CALPHADDatabaseModel& x);

  virtual 
  ~CALPHADDatabaseModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDProject_optional IDProject_;
  Thermodynamic_optional Thermodynamic_;
  Physical_optional Physical_;
  Mobility_optional Mobility_;
};

bool
operator== (const CALPHADDatabaseModel&, const CALPHADDatabaseModel&);

bool
operator!= (const CALPHADDatabaseModel&, const CALPHADDatabaseModel&);


class CaseModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDProject
  //
  typedef ::xml_schema::int_ IDProject_type;
  typedef ::xsd::cxx::tree::optional< IDProject_type > IDProject_optional;
  typedef ::xsd::cxx::tree::traits< IDProject_type, char > IDProject_traits;

  const IDProject_optional&
  IDProject () const;

  IDProject_optional&
  IDProject ();

  void
  IDProject (const IDProject_type& x);

  void
  IDProject (const IDProject_optional& x);

  // IDGroup
  //
  typedef ::xml_schema::int_ IDGroup_type;
  typedef ::xsd::cxx::tree::optional< IDGroup_type > IDGroup_optional;
  typedef ::xsd::cxx::tree::traits< IDGroup_type, char > IDGroup_traits;

  const IDGroup_optional&
  IDGroup () const;

  IDGroup_optional&
  IDGroup ();

  void
  IDGroup (const IDGroup_type& x);

  void
  IDGroup (const IDGroup_optional& x);

  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::unique_ptr< Name_type > p);

  // Script
  //
  typedef ::xml_schema::string Script_type;
  typedef ::xsd::cxx::tree::optional< Script_type > Script_optional;
  typedef ::xsd::cxx::tree::traits< Script_type, char > Script_traits;

  const Script_optional&
  Script () const;

  Script_optional&
  Script ();

  void
  Script (const Script_type& x);

  void
  Script (const Script_optional& x);

  void
  Script (::std::unique_ptr< Script_type > p);

  // Date
  //
  typedef ::xml_schema::string Date_type;
  typedef ::xsd::cxx::tree::optional< Date_type > Date_optional;
  typedef ::xsd::cxx::tree::traits< Date_type, char > Date_traits;

  const Date_optional&
  Date () const;

  Date_optional&
  Date ();

  void
  Date (const Date_type& x);

  void
  Date (const Date_optional& x);

  void
  Date (::std::unique_ptr< Date_type > p);

  // PosX
  //
  typedef ::xml_schema::double_ PosX_type;
  typedef ::xsd::cxx::tree::optional< PosX_type > PosX_optional;
  typedef ::xsd::cxx::tree::traits< PosX_type, char, ::xsd::cxx::tree::schema_type::double_ > PosX_traits;

  const PosX_optional&
  PosX () const;

  PosX_optional&
  PosX ();

  void
  PosX (const PosX_type& x);

  void
  PosX (const PosX_optional& x);

  // PosY
  //
  typedef ::xml_schema::double_ PosY_type;
  typedef ::xsd::cxx::tree::optional< PosY_type > PosY_optional;
  typedef ::xsd::cxx::tree::traits< PosY_type, char, ::xsd::cxx::tree::schema_type::double_ > PosY_traits;

  const PosY_optional&
  PosY () const;

  PosY_optional&
  PosY ();

  void
  PosY (const PosY_type& x);

  void
  PosY (const PosY_optional& x);

  // PosZ
  //
  typedef ::xml_schema::double_ PosZ_type;
  typedef ::xsd::cxx::tree::optional< PosZ_type > PosZ_optional;
  typedef ::xsd::cxx::tree::traits< PosZ_type, char, ::xsd::cxx::tree::schema_type::double_ > PosZ_traits;

  const PosZ_optional&
  PosZ () const;

  PosZ_optional&
  PosZ ();

  void
  PosZ (const PosZ_type& x);

  void
  PosZ (const PosZ_optional& x);

  // Constructors.
  //
  CaseModel ();

  CaseModel (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  CaseModel (const CaseModel& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual CaseModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CaseModel&
  operator= (const CaseModel& x);

  virtual 
  ~CaseModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDProject_optional IDProject_;
  IDGroup_optional IDGroup_;
  Name_optional Name_;
  Script_optional Script_;
  Date_optional Date_;
  PosX_optional PosX_;
  PosY_optional PosY_;
  PosZ_optional PosZ_;
};

bool
operator== (const CaseModel&, const CaseModel&);

bool
operator!= (const CaseModel&, const CaseModel&);


class ElementModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // Name
  //
  typedef ::xml_schema::int_ Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  // Constructors.
  //
  ElementModel ();

  ElementModel (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  ElementModel (const ElementModel& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual ElementModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ElementModel&
  operator= (const ElementModel& x);

  virtual 
  ~ElementModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  Name_optional Name_;
};

bool
operator== (const ElementModel&, const ElementModel&);

bool
operator!= (const ElementModel&, const ElementModel&);


class ElementCompositionModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDCase
  //
  typedef ::xml_schema::int_ IDCase_type;
  typedef ::xsd::cxx::tree::optional< IDCase_type > IDCase_optional;
  typedef ::xsd::cxx::tree::traits< IDCase_type, char > IDCase_traits;

  const IDCase_optional&
  IDCase () const;

  IDCase_optional&
  IDCase ();

  void
  IDCase (const IDCase_type& x);

  void
  IDCase (const IDCase_optional& x);

  // IDElement
  //
  typedef ::xml_schema::int_ IDElement_type;
  typedef ::xsd::cxx::tree::optional< IDElement_type > IDElement_optional;
  typedef ::xsd::cxx::tree::traits< IDElement_type, char > IDElement_traits;

  const IDElement_optional&
  IDElement () const;

  IDElement_optional&
  IDElement ();

  void
  IDElement (const IDElement_type& x);

  void
  IDElement (const IDElement_optional& x);

  // TypeComposition
  //
  typedef ::xml_schema::string TypeComposition_type;
  typedef ::xsd::cxx::tree::optional< TypeComposition_type > TypeComposition_optional;
  typedef ::xsd::cxx::tree::traits< TypeComposition_type, char > TypeComposition_traits;

  const TypeComposition_optional&
  TypeComposition () const;

  TypeComposition_optional&
  TypeComposition ();

  void
  TypeComposition (const TypeComposition_type& x);

  void
  TypeComposition (const TypeComposition_optional& x);

  void
  TypeComposition (::std::unique_ptr< TypeComposition_type > p);

  // Value
  //
  typedef ::xml_schema::double_ Value_type;
  typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
  typedef ::xsd::cxx::tree::traits< Value_type, char, ::xsd::cxx::tree::schema_type::double_ > Value_traits;

  const Value_optional&
  Value () const;

  Value_optional&
  Value ();

  void
  Value (const Value_type& x);

  void
  Value (const Value_optional& x);

  // Constructors.
  //
  ElementCompositionModel ();

  ElementCompositionModel (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  ElementCompositionModel (const ElementCompositionModel& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual ElementCompositionModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ElementCompositionModel&
  operator= (const ElementCompositionModel& x);

  virtual 
  ~ElementCompositionModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDCase_optional IDCase_;
  IDElement_optional IDElement_;
  TypeComposition_optional TypeComposition_;
  Value_optional Value_;
};

bool
operator== (const ElementCompositionModel&, const ElementCompositionModel&);

bool
operator!= (const ElementCompositionModel&, const ElementCompositionModel&);


class EquilibriumConfigurationModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDCase
  //
  typedef ::xml_schema::int_ IDCase_type;
  typedef ::xsd::cxx::tree::optional< IDCase_type > IDCase_optional;
  typedef ::xsd::cxx::tree::traits< IDCase_type, char > IDCase_traits;

  const IDCase_optional&
  IDCase () const;

  IDCase_optional&
  IDCase ();

  void
  IDCase (const IDCase_type& x);

  void
  IDCase (const IDCase_optional& x);

  // Temperature
  //
  typedef ::xml_schema::double_ Temperature_type;
  typedef ::xsd::cxx::tree::optional< Temperature_type > Temperature_optional;
  typedef ::xsd::cxx::tree::traits< Temperature_type, char, ::xsd::cxx::tree::schema_type::double_ > Temperature_traits;

  const Temperature_optional&
  Temperature () const;

  Temperature_optional&
  Temperature ();

  void
  Temperature (const Temperature_type& x);

  void
  Temperature (const Temperature_optional& x);

  // StartTemperature
  //
  typedef ::xml_schema::double_ StartTemperature_type;
  typedef ::xsd::cxx::tree::optional< StartTemperature_type > StartTemperature_optional;
  typedef ::xsd::cxx::tree::traits< StartTemperature_type, char, ::xsd::cxx::tree::schema_type::double_ > StartTemperature_traits;

  const StartTemperature_optional&
  StartTemperature () const;

  StartTemperature_optional&
  StartTemperature ();

  void
  StartTemperature (const StartTemperature_type& x);

  void
  StartTemperature (const StartTemperature_optional& x);

  // EndTemperature
  //
  typedef ::xml_schema::double_ EndTemperature_type;
  typedef ::xsd::cxx::tree::optional< EndTemperature_type > EndTemperature_optional;
  typedef ::xsd::cxx::tree::traits< EndTemperature_type, char, ::xsd::cxx::tree::schema_type::double_ > EndTemperature_traits;

  const EndTemperature_optional&
  EndTemperature () const;

  EndTemperature_optional&
  EndTemperature ();

  void
  EndTemperature (const EndTemperature_type& x);

  void
  EndTemperature (const EndTemperature_optional& x);

  // TemperatureType
  //
  typedef ::xml_schema::string TemperatureType_type;
  typedef ::xsd::cxx::tree::optional< TemperatureType_type > TemperatureType_optional;
  typedef ::xsd::cxx::tree::traits< TemperatureType_type, char > TemperatureType_traits;

  const TemperatureType_optional&
  TemperatureType () const;

  TemperatureType_optional&
  TemperatureType ();

  void
  TemperatureType (const TemperatureType_type& x);

  void
  TemperatureType (const TemperatureType_optional& x);

  void
  TemperatureType (::std::unique_ptr< TemperatureType_type > p);

  // StepSize
  //
  typedef ::xml_schema::double_ StepSize_type;
  typedef ::xsd::cxx::tree::optional< StepSize_type > StepSize_optional;
  typedef ::xsd::cxx::tree::traits< StepSize_type, char, ::xsd::cxx::tree::schema_type::double_ > StepSize_traits;

  const StepSize_optional&
  StepSize () const;

  StepSize_optional&
  StepSize ();

  void
  StepSize (const StepSize_type& x);

  void
  StepSize (const StepSize_optional& x);

  // Pressure
  //
  typedef ::xml_schema::double_ Pressure_type;
  typedef ::xsd::cxx::tree::optional< Pressure_type > Pressure_optional;
  typedef ::xsd::cxx::tree::traits< Pressure_type, char, ::xsd::cxx::tree::schema_type::double_ > Pressure_traits;

  const Pressure_optional&
  Pressure () const;

  Pressure_optional&
  Pressure ();

  void
  Pressure (const Pressure_type& x);

  void
  Pressure (const Pressure_optional& x);

  // Constructors.
  //
  EquilibriumConfigurationModel ();

  EquilibriumConfigurationModel (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  EquilibriumConfigurationModel (const EquilibriumConfigurationModel& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual EquilibriumConfigurationModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  EquilibriumConfigurationModel&
  operator= (const EquilibriumConfigurationModel& x);

  virtual 
  ~EquilibriumConfigurationModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDCase_optional IDCase_;
  Temperature_optional Temperature_;
  StartTemperature_optional StartTemperature_;
  EndTemperature_optional EndTemperature_;
  TemperatureType_optional TemperatureType_;
  StepSize_optional StepSize_;
  Pressure_optional Pressure_;
};

bool
operator== (const EquilibriumConfigurationModel&, const EquilibriumConfigurationModel&);

bool
operator!= (const EquilibriumConfigurationModel&, const EquilibriumConfigurationModel&);


class EquilibriumPhaseFractionModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDCase
  //
  typedef ::xml_schema::int_ IDCase_type;
  typedef ::xsd::cxx::tree::optional< IDCase_type > IDCase_optional;
  typedef ::xsd::cxx::tree::traits< IDCase_type, char > IDCase_traits;

  const IDCase_optional&
  IDCase () const;

  IDCase_optional&
  IDCase ();

  void
  IDCase (const IDCase_type& x);

  void
  IDCase (const IDCase_optional& x);

  // Temperature
  //
  typedef ::xml_schema::double_ Temperature_type;
  typedef ::xsd::cxx::tree::optional< Temperature_type > Temperature_optional;
  typedef ::xsd::cxx::tree::traits< Temperature_type, char, ::xsd::cxx::tree::schema_type::double_ > Temperature_traits;

  const Temperature_optional&
  Temperature () const;

  Temperature_optional&
  Temperature ();

  void
  Temperature (const Temperature_type& x);

  void
  Temperature (const Temperature_optional& x);

  // Value
  //
  typedef ::xml_schema::double_ Value_type;
  typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
  typedef ::xsd::cxx::tree::traits< Value_type, char, ::xsd::cxx::tree::schema_type::double_ > Value_traits;

  const Value_optional&
  Value () const;

  Value_optional&
  Value ();

  void
  Value (const Value_type& x);

  void
  Value (const Value_optional& x);

  // Constructors.
  //
  EquilibriumPhaseFractionModel ();

  EquilibriumPhaseFractionModel (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  EquilibriumPhaseFractionModel (const EquilibriumPhaseFractionModel& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual EquilibriumPhaseFractionModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  EquilibriumPhaseFractionModel&
  operator= (const EquilibriumPhaseFractionModel& x);

  virtual 
  ~EquilibriumPhaseFractionModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDCase_optional IDCase_;
  Temperature_optional Temperature_;
  Value_optional Value_;
};

bool
operator== (const EquilibriumPhaseFractionModel&, const EquilibriumPhaseFractionModel&);

bool
operator!= (const EquilibriumPhaseFractionModel&, const EquilibriumPhaseFractionModel&);


class HeatTreatmentModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDCase
  //
  typedef ::xml_schema::int_ IDCase_type;
  typedef ::xsd::cxx::tree::optional< IDCase_type > IDCase_optional;
  typedef ::xsd::cxx::tree::traits< IDCase_type, char > IDCase_traits;

  const IDCase_optional&
  IDCase () const;

  IDCase_optional&
  IDCase ();

  void
  IDCase (const IDCase_type& x);

  void
  IDCase (const IDCase_optional& x);

  // Name
  //
  typedef ::xml_schema::double_ Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char, ::xsd::cxx::tree::schema_type::double_ > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  // MaxTemperatureStep
  //
  typedef ::xml_schema::int_ MaxTemperatureStep_type;
  typedef ::xsd::cxx::tree::optional< MaxTemperatureStep_type > MaxTemperatureStep_optional;
  typedef ::xsd::cxx::tree::traits< MaxTemperatureStep_type, char > MaxTemperatureStep_traits;

  const MaxTemperatureStep_optional&
  MaxTemperatureStep () const;

  MaxTemperatureStep_optional&
  MaxTemperatureStep ();

  void
  MaxTemperatureStep (const MaxTemperatureStep_type& x);

  void
  MaxTemperatureStep (const MaxTemperatureStep_optional& x);

  // IDPrecipitationDomain
  //
  typedef ::xml_schema::int_ IDPrecipitationDomain_type;
  typedef ::xsd::cxx::tree::optional< IDPrecipitationDomain_type > IDPrecipitationDomain_optional;
  typedef ::xsd::cxx::tree::traits< IDPrecipitationDomain_type, char > IDPrecipitationDomain_traits;

  const IDPrecipitationDomain_optional&
  IDPrecipitationDomain () const;

  IDPrecipitationDomain_optional&
  IDPrecipitationDomain ();

  void
  IDPrecipitationDomain (const IDPrecipitationDomain_type& x);

  void
  IDPrecipitationDomain (const IDPrecipitationDomain_optional& x);

  // StartTemperature
  //
  typedef ::xml_schema::double_ StartTemperature_type;
  typedef ::xsd::cxx::tree::optional< StartTemperature_type > StartTemperature_optional;
  typedef ::xsd::cxx::tree::traits< StartTemperature_type, char, ::xsd::cxx::tree::schema_type::double_ > StartTemperature_traits;

  const StartTemperature_optional&
  StartTemperature () const;

  StartTemperature_optional&
  StartTemperature ();

  void
  StartTemperature (const StartTemperature_type& x);

  void
  StartTemperature (const StartTemperature_optional& x);

  // Constructors.
  //
  HeatTreatmentModel ();

  HeatTreatmentModel (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  HeatTreatmentModel (const HeatTreatmentModel& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual HeatTreatmentModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  HeatTreatmentModel&
  operator= (const HeatTreatmentModel& x);

  virtual 
  ~HeatTreatmentModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDCase_optional IDCase_;
  Name_optional Name_;
  MaxTemperatureStep_optional MaxTemperatureStep_;
  IDPrecipitationDomain_optional IDPrecipitationDomain_;
  StartTemperature_optional StartTemperature_;
};

bool
operator== (const HeatTreatmentModel&, const HeatTreatmentModel&);

bool
operator!= (const HeatTreatmentModel&, const HeatTreatmentModel&);


class HeatTreatmentProfileModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDHeatTreatment
  //
  typedef ::xml_schema::int_ IDHeatTreatment_type;
  typedef ::xsd::cxx::tree::optional< IDHeatTreatment_type > IDHeatTreatment_optional;
  typedef ::xsd::cxx::tree::traits< IDHeatTreatment_type, char > IDHeatTreatment_traits;

  const IDHeatTreatment_optional&
  IDHeatTreatment () const;

  IDHeatTreatment_optional&
  IDHeatTreatment ();

  void
  IDHeatTreatment (const IDHeatTreatment_type& x);

  void
  IDHeatTreatment (const IDHeatTreatment_optional& x);

  // Time
  //
  typedef ::xml_schema::double_ Time_type;
  typedef ::xsd::cxx::tree::optional< Time_type > Time_optional;
  typedef ::xsd::cxx::tree::traits< Time_type, char, ::xsd::cxx::tree::schema_type::double_ > Time_traits;

  const Time_optional&
  Time () const;

  Time_optional&
  Time ();

  void
  Time (const Time_type& x);

  void
  Time (const Time_optional& x);

  // Temperature
  //
  typedef ::xml_schema::double_ Temperature_type;
  typedef ::xsd::cxx::tree::optional< Temperature_type > Temperature_optional;
  typedef ::xsd::cxx::tree::traits< Temperature_type, char, ::xsd::cxx::tree::schema_type::double_ > Temperature_traits;

  const Temperature_optional&
  Temperature () const;

  Temperature_optional&
  Temperature ();

  void
  Temperature (const Temperature_type& x);

  void
  Temperature (const Temperature_optional& x);

  // Constructors.
  //
  HeatTreatmentProfileModel ();

  HeatTreatmentProfileModel (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  HeatTreatmentProfileModel (const HeatTreatmentProfileModel& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  virtual HeatTreatmentProfileModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  HeatTreatmentProfileModel&
  operator= (const HeatTreatmentProfileModel& x);

  virtual 
  ~HeatTreatmentProfileModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDHeatTreatment_optional IDHeatTreatment_;
  Time_optional Time_;
  Temperature_optional Temperature_;
};

bool
operator== (const HeatTreatmentProfileModel&, const HeatTreatmentProfileModel&);

bool
operator!= (const HeatTreatmentProfileModel&, const HeatTreatmentProfileModel&);


class HeatTreatmentSegmentModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // StepIndex
  //
  typedef ::xml_schema::int_ StepIndex_type;
  typedef ::xsd::cxx::tree::optional< StepIndex_type > StepIndex_optional;
  typedef ::xsd::cxx::tree::traits< StepIndex_type, char > StepIndex_traits;

  const StepIndex_optional&
  StepIndex () const;

  StepIndex_optional&
  StepIndex ();

  void
  StepIndex (const StepIndex_type& x);

  void
  StepIndex (const StepIndex_optional& x);

  // IDHeatTreatment
  //
  typedef ::xml_schema::int_ IDHeatTreatment_type;
  typedef ::xsd::cxx::tree::optional< IDHeatTreatment_type > IDHeatTreatment_optional;
  typedef ::xsd::cxx::tree::traits< IDHeatTreatment_type, char > IDHeatTreatment_traits;

  const IDHeatTreatment_optional&
  IDHeatTreatment () const;

  IDHeatTreatment_optional&
  IDHeatTreatment ();

  void
  IDHeatTreatment (const IDHeatTreatment_type& x);

  void
  IDHeatTreatment (const IDHeatTreatment_optional& x);

  // IDPrecipitationDomain
  //
  typedef ::xml_schema::int_ IDPrecipitationDomain_type;
  typedef ::xsd::cxx::tree::optional< IDPrecipitationDomain_type > IDPrecipitationDomain_optional;
  typedef ::xsd::cxx::tree::traits< IDPrecipitationDomain_type, char > IDPrecipitationDomain_traits;

  const IDPrecipitationDomain_optional&
  IDPrecipitationDomain () const;

  IDPrecipitationDomain_optional&
  IDPrecipitationDomain ();

  void
  IDPrecipitationDomain (const IDPrecipitationDomain_type& x);

  void
  IDPrecipitationDomain (const IDPrecipitationDomain_optional& x);

  // EndTemperature
  //
  typedef ::xml_schema::double_ EndTemperature_type;
  typedef ::xsd::cxx::tree::optional< EndTemperature_type > EndTemperature_optional;
  typedef ::xsd::cxx::tree::traits< EndTemperature_type, char, ::xsd::cxx::tree::schema_type::double_ > EndTemperature_traits;

  const EndTemperature_optional&
  EndTemperature () const;

  EndTemperature_optional&
  EndTemperature ();

  void
  EndTemperature (const EndTemperature_type& x);

  void
  EndTemperature (const EndTemperature_optional& x);

  // TemperatureGradient
  //
  typedef ::xml_schema::double_ TemperatureGradient_type;
  typedef ::xsd::cxx::tree::optional< TemperatureGradient_type > TemperatureGradient_optional;
  typedef ::xsd::cxx::tree::traits< TemperatureGradient_type, char, ::xsd::cxx::tree::schema_type::double_ > TemperatureGradient_traits;

  const TemperatureGradient_optional&
  TemperatureGradient () const;

  TemperatureGradient_optional&
  TemperatureGradient ();

  void
  TemperatureGradient (const TemperatureGradient_type& x);

  void
  TemperatureGradient (const TemperatureGradient_optional& x);

  // Duration
  //
  typedef ::xml_schema::double_ Duration_type;
  typedef ::xsd::cxx::tree::optional< Duration_type > Duration_optional;
  typedef ::xsd::cxx::tree::traits< Duration_type, char, ::xsd::cxx::tree::schema_type::double_ > Duration_traits;

  const Duration_optional&
  Duration () const;

  Duration_optional&
  Duration ();

  void
  Duration (const Duration_type& x);

  void
  Duration (const Duration_optional& x);

  // Constructors.
  //
  HeatTreatmentSegmentModel ();

  HeatTreatmentSegmentModel (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  HeatTreatmentSegmentModel (const HeatTreatmentSegmentModel& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  virtual HeatTreatmentSegmentModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  HeatTreatmentSegmentModel&
  operator= (const HeatTreatmentSegmentModel& x);

  virtual 
  ~HeatTreatmentSegmentModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  StepIndex_optional StepIndex_;
  IDHeatTreatment_optional IDHeatTreatment_;
  IDPrecipitationDomain_optional IDPrecipitationDomain_;
  EndTemperature_optional EndTemperature_;
  TemperatureGradient_optional TemperatureGradient_;
  Duration_optional Duration_;
};

bool
operator== (const HeatTreatmentSegmentModel&, const HeatTreatmentSegmentModel&);

bool
operator!= (const HeatTreatmentSegmentModel&, const HeatTreatmentSegmentModel&);


class PhaseModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::unique_ptr< Name_type > p);

  // DBType
  //
  typedef ::xml_schema::int_ DBType_type;
  typedef ::xsd::cxx::tree::optional< DBType_type > DBType_optional;
  typedef ::xsd::cxx::tree::traits< DBType_type, char > DBType_traits;

  const DBType_optional&
  DBType () const;

  DBType_optional&
  DBType ();

  void
  DBType (const DBType_type& x);

  void
  DBType (const DBType_optional& x);

  // Constructors.
  //
  PhaseModel ();

  PhaseModel (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  PhaseModel (const PhaseModel& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual PhaseModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  PhaseModel&
  operator= (const PhaseModel& x);

  virtual 
  ~PhaseModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  Name_optional Name_;
  DBType_optional DBType_;
};

bool
operator== (const PhaseModel&, const PhaseModel&);

bool
operator!= (const PhaseModel&, const PhaseModel&);


class PrecipitationSimulationDataModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDPrecipitationPhase
  //
  typedef ::xml_schema::int_ IDPrecipitationPhase_type;
  typedef ::xsd::cxx::tree::optional< IDPrecipitationPhase_type > IDPrecipitationPhase_optional;
  typedef ::xsd::cxx::tree::traits< IDPrecipitationPhase_type, char > IDPrecipitationPhase_traits;

  const IDPrecipitationPhase_optional&
  IDPrecipitationPhase () const;

  IDPrecipitationPhase_optional&
  IDPrecipitationPhase ();

  void
  IDPrecipitationPhase (const IDPrecipitationPhase_type& x);

  void
  IDPrecipitationPhase (const IDPrecipitationPhase_optional& x);

  // IDHeatTreatment
  //
  typedef ::xml_schema::int_ IDHeatTreatment_type;
  typedef ::xsd::cxx::tree::optional< IDHeatTreatment_type > IDHeatTreatment_optional;
  typedef ::xsd::cxx::tree::traits< IDHeatTreatment_type, char > IDHeatTreatment_traits;

  const IDHeatTreatment_optional&
  IDHeatTreatment () const;

  IDHeatTreatment_optional&
  IDHeatTreatment ();

  void
  IDHeatTreatment (const IDHeatTreatment_type& x);

  void
  IDHeatTreatment (const IDHeatTreatment_optional& x);

  // Time
  //
  typedef ::xml_schema::double_ Time_type;
  typedef ::xsd::cxx::tree::optional< Time_type > Time_optional;
  typedef ::xsd::cxx::tree::traits< Time_type, char, ::xsd::cxx::tree::schema_type::double_ > Time_traits;

  const Time_optional&
  Time () const;

  Time_optional&
  Time ();

  void
  Time (const Time_type& x);

  void
  Time (const Time_optional& x);

  // PhaseFraction
  //
  typedef ::xml_schema::double_ PhaseFraction_type;
  typedef ::xsd::cxx::tree::optional< PhaseFraction_type > PhaseFraction_optional;
  typedef ::xsd::cxx::tree::traits< PhaseFraction_type, char, ::xsd::cxx::tree::schema_type::double_ > PhaseFraction_traits;

  const PhaseFraction_optional&
  PhaseFraction () const;

  PhaseFraction_optional&
  PhaseFraction ();

  void
  PhaseFraction (const PhaseFraction_type& x);

  void
  PhaseFraction (const PhaseFraction_optional& x);

  // NumberDensity
  //
  typedef ::xml_schema::double_ NumberDensity_type;
  typedef ::xsd::cxx::tree::optional< NumberDensity_type > NumberDensity_optional;
  typedef ::xsd::cxx::tree::traits< NumberDensity_type, char, ::xsd::cxx::tree::schema_type::double_ > NumberDensity_traits;

  const NumberDensity_optional&
  NumberDensity () const;

  NumberDensity_optional&
  NumberDensity ();

  void
  NumberDensity (const NumberDensity_type& x);

  void
  NumberDensity (const NumberDensity_optional& x);

  // MeanRadius
  //
  typedef ::xml_schema::double_ MeanRadius_type;
  typedef ::xsd::cxx::tree::optional< MeanRadius_type > MeanRadius_optional;
  typedef ::xsd::cxx::tree::traits< MeanRadius_type, char, ::xsd::cxx::tree::schema_type::double_ > MeanRadius_traits;

  const MeanRadius_optional&
  MeanRadius () const;

  MeanRadius_optional&
  MeanRadius ();

  void
  MeanRadius (const MeanRadius_type& x);

  void
  MeanRadius (const MeanRadius_optional& x);

  // Constructors.
  //
  PrecipitationSimulationDataModel ();

  PrecipitationSimulationDataModel (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  PrecipitationSimulationDataModel (const PrecipitationSimulationDataModel& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual PrecipitationSimulationDataModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  PrecipitationSimulationDataModel&
  operator= (const PrecipitationSimulationDataModel& x);

  virtual 
  ~PrecipitationSimulationDataModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDPrecipitationPhase_optional IDPrecipitationPhase_;
  IDHeatTreatment_optional IDHeatTreatment_;
  Time_optional Time_;
  PhaseFraction_optional PhaseFraction_;
  NumberDensity_optional NumberDensity_;
  MeanRadius_optional MeanRadius_;
};

bool
operator== (const PrecipitationSimulationDataModel&, const PrecipitationSimulationDataModel&);

bool
operator!= (const PrecipitationSimulationDataModel&, const PrecipitationSimulationDataModel&);


class PrecipitationDomainModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDCase
  //
  typedef ::xml_schema::int_ IDCase_type;
  typedef ::xsd::cxx::tree::optional< IDCase_type > IDCase_optional;
  typedef ::xsd::cxx::tree::traits< IDCase_type, char > IDCase_traits;

  const IDCase_optional&
  IDCase () const;

  IDCase_optional&
  IDCase ();

  void
  IDCase (const IDCase_type& x);

  void
  IDCase (const IDCase_optional& x);

  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::unique_ptr< Name_type > p);

  // IDPhase
  //
  typedef ::xml_schema::int_ IDPhase_type;
  typedef ::xsd::cxx::tree::optional< IDPhase_type > IDPhase_optional;
  typedef ::xsd::cxx::tree::traits< IDPhase_type, char > IDPhase_traits;

  const IDPhase_optional&
  IDPhase () const;

  IDPhase_optional&
  IDPhase ();

  void
  IDPhase (const IDPhase_type& x);

  void
  IDPhase (const IDPhase_optional& x);

  // InitialGrainDiameter
  //
  typedef ::xml_schema::double_ InitialGrainDiameter_type;
  typedef ::xsd::cxx::tree::optional< InitialGrainDiameter_type > InitialGrainDiameter_optional;
  typedef ::xsd::cxx::tree::traits< InitialGrainDiameter_type, char, ::xsd::cxx::tree::schema_type::double_ > InitialGrainDiameter_traits;

  const InitialGrainDiameter_optional&
  InitialGrainDiameter () const;

  InitialGrainDiameter_optional&
  InitialGrainDiameter ();

  void
  InitialGrainDiameter (const InitialGrainDiameter_type& x);

  void
  InitialGrainDiameter (const InitialGrainDiameter_optional& x);

  // EquilibriumDiDe
  //
  typedef ::xml_schema::double_ EquilibriumDiDe_type;
  typedef ::xsd::cxx::tree::optional< EquilibriumDiDe_type > EquilibriumDiDe_optional;
  typedef ::xsd::cxx::tree::traits< EquilibriumDiDe_type, char, ::xsd::cxx::tree::schema_type::double_ > EquilibriumDiDe_traits;

  const EquilibriumDiDe_optional&
  EquilibriumDiDe () const;

  EquilibriumDiDe_optional&
  EquilibriumDiDe ();

  void
  EquilibriumDiDe (const EquilibriumDiDe_type& x);

  void
  EquilibriumDiDe (const EquilibriumDiDe_optional& x);

  // Constructors.
  //
  PrecipitationDomainModel ();

  PrecipitationDomainModel (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  PrecipitationDomainModel (const PrecipitationDomainModel& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual PrecipitationDomainModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  PrecipitationDomainModel&
  operator= (const PrecipitationDomainModel& x);

  virtual 
  ~PrecipitationDomainModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDCase_optional IDCase_;
  Name_optional Name_;
  IDPhase_optional IDPhase_;
  InitialGrainDiameter_optional InitialGrainDiameter_;
  EquilibriumDiDe_optional EquilibriumDiDe_;
};

bool
operator== (const PrecipitationDomainModel&, const PrecipitationDomainModel&);

bool
operator!= (const PrecipitationDomainModel&, const PrecipitationDomainModel&);


class PrecipitationPhaseModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDCase
  //
  typedef ::xml_schema::int_ IDCase_type;
  typedef ::xsd::cxx::tree::optional< IDCase_type > IDCase_optional;
  typedef ::xsd::cxx::tree::traits< IDCase_type, char > IDCase_traits;

  const IDCase_optional&
  IDCase () const;

  IDCase_optional&
  IDCase ();

  void
  IDCase (const IDCase_type& x);

  void
  IDCase (const IDCase_optional& x);

  // IDPhase
  //
  typedef ::xml_schema::int_ IDPhase_type;
  typedef ::xsd::cxx::tree::optional< IDPhase_type > IDPhase_optional;
  typedef ::xsd::cxx::tree::traits< IDPhase_type, char > IDPhase_traits;

  const IDPhase_optional&
  IDPhase () const;

  IDPhase_optional&
  IDPhase ();

  void
  IDPhase (const IDPhase_type& x);

  void
  IDPhase (const IDPhase_optional& x);

  // NumberSizeClasses
  //
  typedef ::xml_schema::int_ NumberSizeClasses_type;
  typedef ::xsd::cxx::tree::optional< NumberSizeClasses_type > NumberSizeClasses_optional;
  typedef ::xsd::cxx::tree::traits< NumberSizeClasses_type, char > NumberSizeClasses_traits;

  const NumberSizeClasses_optional&
  NumberSizeClasses () const;

  NumberSizeClasses_optional&
  NumberSizeClasses ();

  void
  NumberSizeClasses (const NumberSizeClasses_type& x);

  void
  NumberSizeClasses (const NumberSizeClasses_optional& x);

  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::unique_ptr< Name_type > p);

  // NucleationSites
  //
  typedef ::xml_schema::string NucleationSites_type;
  typedef ::xsd::cxx::tree::optional< NucleationSites_type > NucleationSites_optional;
  typedef ::xsd::cxx::tree::traits< NucleationSites_type, char > NucleationSites_traits;

  const NucleationSites_optional&
  NucleationSites () const;

  NucleationSites_optional&
  NucleationSites ();

  void
  NucleationSites (const NucleationSites_type& x);

  void
  NucleationSites (const NucleationSites_optional& x);

  void
  NucleationSites (::std::unique_ptr< NucleationSites_type > p);

  // IDPrecipitationDomain
  //
  typedef ::xml_schema::int_ IDPrecipitationDomain_type;
  typedef ::xsd::cxx::tree::optional< IDPrecipitationDomain_type > IDPrecipitationDomain_optional;
  typedef ::xsd::cxx::tree::traits< IDPrecipitationDomain_type, char > IDPrecipitationDomain_traits;

  const IDPrecipitationDomain_optional&
  IDPrecipitationDomain () const;

  IDPrecipitationDomain_optional&
  IDPrecipitationDomain ();

  void
  IDPrecipitationDomain (const IDPrecipitationDomain_type& x);

  void
  IDPrecipitationDomain (const IDPrecipitationDomain_optional& x);

  // Constructors.
  //
  PrecipitationPhaseModel ();

  PrecipitationPhaseModel (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  PrecipitationPhaseModel (const PrecipitationPhaseModel& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  virtual PrecipitationPhaseModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  PrecipitationPhaseModel&
  operator= (const PrecipitationPhaseModel& x);

  virtual 
  ~PrecipitationPhaseModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDCase_optional IDCase_;
  IDPhase_optional IDPhase_;
  NumberSizeClasses_optional NumberSizeClasses_;
  Name_optional Name_;
  NucleationSites_optional NucleationSites_;
  IDPrecipitationDomain_optional IDPrecipitationDomain_;
};

bool
operator== (const PrecipitationPhaseModel&, const PrecipitationPhaseModel&);

bool
operator!= (const PrecipitationPhaseModel&, const PrecipitationPhaseModel&);


class ProjectModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_optional&
  Name () const;

  Name_optional&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (const Name_optional& x);

  void
  Name (::std::unique_ptr< Name_type > p);

  // APIName
  //
  typedef ::xml_schema::string APIName_type;
  typedef ::xsd::cxx::tree::optional< APIName_type > APIName_optional;
  typedef ::xsd::cxx::tree::traits< APIName_type, char > APIName_traits;

  const APIName_optional&
  APIName () const;

  APIName_optional&
  APIName ();

  void
  APIName (const APIName_type& x);

  void
  APIName (const APIName_optional& x);

  void
  APIName (::std::unique_ptr< APIName_type > p);

  // External_APIName
  //
  typedef ::xml_schema::string External_APIName_type;
  typedef ::xsd::cxx::tree::optional< External_APIName_type > External_APIName_optional;
  typedef ::xsd::cxx::tree::traits< External_APIName_type, char > External_APIName_traits;

  const External_APIName_optional&
  External_APIName () const;

  External_APIName_optional&
  External_APIName ();

  void
  External_APIName (const External_APIName_type& x);

  void
  External_APIName (const External_APIName_optional& x);

  void
  External_APIName (::std::unique_ptr< External_APIName_type > p);

  // Constructors.
  //
  ProjectModel ();

  ProjectModel (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  ProjectModel (const ProjectModel& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual ProjectModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ProjectModel&
  operator= (const ProjectModel& x);

  virtual 
  ~ProjectModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  Name_optional Name_;
  APIName_optional APIName_;
  External_APIName_optional External_APIName_;
};

bool
operator== (const ProjectModel&, const ProjectModel&);

bool
operator!= (const ProjectModel&, const ProjectModel&);


class ScheilConfigurationModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDCase
  //
  typedef ::xml_schema::int_ IDCase_type;
  typedef ::xsd::cxx::tree::optional< IDCase_type > IDCase_optional;
  typedef ::xsd::cxx::tree::traits< IDCase_type, char > IDCase_traits;

  const IDCase_optional&
  IDCase () const;

  IDCase_optional&
  IDCase ();

  void
  IDCase (const IDCase_type& x);

  void
  IDCase (const IDCase_optional& x);

  // StartTemperature
  //
  typedef ::xml_schema::double_ StartTemperature_type;
  typedef ::xsd::cxx::tree::optional< StartTemperature_type > StartTemperature_optional;
  typedef ::xsd::cxx::tree::traits< StartTemperature_type, char, ::xsd::cxx::tree::schema_type::double_ > StartTemperature_traits;

  const StartTemperature_optional&
  StartTemperature () const;

  StartTemperature_optional&
  StartTemperature ();

  void
  StartTemperature (const StartTemperature_type& x);

  void
  StartTemperature (const StartTemperature_optional& x);

  // EndTemperature
  //
  typedef ::xml_schema::double_ EndTemperature_type;
  typedef ::xsd::cxx::tree::optional< EndTemperature_type > EndTemperature_optional;
  typedef ::xsd::cxx::tree::traits< EndTemperature_type, char, ::xsd::cxx::tree::schema_type::double_ > EndTemperature_traits;

  const EndTemperature_optional&
  EndTemperature () const;

  EndTemperature_optional&
  EndTemperature ();

  void
  EndTemperature (const EndTemperature_type& x);

  void
  EndTemperature (const EndTemperature_optional& x);

  // StepSize
  //
  typedef ::xml_schema::double_ StepSize_type;
  typedef ::xsd::cxx::tree::optional< StepSize_type > StepSize_optional;
  typedef ::xsd::cxx::tree::traits< StepSize_type, char, ::xsd::cxx::tree::schema_type::double_ > StepSize_traits;

  const StepSize_optional&
  StepSize () const;

  StepSize_optional&
  StepSize ();

  void
  StepSize (const StepSize_type& x);

  void
  StepSize (const StepSize_optional& x);

  // DependentPhase
  //
  typedef ::xml_schema::int_ DependentPhase_type;
  typedef ::xsd::cxx::tree::optional< DependentPhase_type > DependentPhase_optional;
  typedef ::xsd::cxx::tree::traits< DependentPhase_type, char > DependentPhase_traits;

  const DependentPhase_optional&
  DependentPhase () const;

  DependentPhase_optional&
  DependentPhase ();

  void
  DependentPhase (const DependentPhase_type& x);

  void
  DependentPhase (const DependentPhase_optional& x);

  // MinimumLiquidFraction
  //
  typedef ::xml_schema::double_ MinimumLiquidFraction_type;
  typedef ::xsd::cxx::tree::optional< MinimumLiquidFraction_type > MinimumLiquidFraction_optional;
  typedef ::xsd::cxx::tree::traits< MinimumLiquidFraction_type, char, ::xsd::cxx::tree::schema_type::double_ > MinimumLiquidFraction_traits;

  const MinimumLiquidFraction_optional&
  MinimumLiquidFraction () const;

  MinimumLiquidFraction_optional&
  MinimumLiquidFraction ();

  void
  MinimumLiquidFraction (const MinimumLiquidFraction_type& x);

  void
  MinimumLiquidFraction (const MinimumLiquidFraction_optional& x);

  // Constructors.
  //
  ScheilConfigurationModel ();

  ScheilConfigurationModel (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  ScheilConfigurationModel (const ScheilConfigurationModel& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual ScheilConfigurationModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ScheilConfigurationModel&
  operator= (const ScheilConfigurationModel& x);

  virtual 
  ~ScheilConfigurationModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDCase_optional IDCase_;
  StartTemperature_optional StartTemperature_;
  EndTemperature_optional EndTemperature_;
  StepSize_optional StepSize_;
  DependentPhase_optional DependentPhase_;
  MinimumLiquidFraction_optional MinimumLiquidFraction_;
};

bool
operator== (const ScheilConfigurationModel&, const ScheilConfigurationModel&);

bool
operator!= (const ScheilConfigurationModel&, const ScheilConfigurationModel&);


class ScheilCumulativeFractionModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDCase
  //
  typedef ::xml_schema::int_ IDCase_type;
  typedef ::xsd::cxx::tree::optional< IDCase_type > IDCase_optional;
  typedef ::xsd::cxx::tree::traits< IDCase_type, char > IDCase_traits;

  const IDCase_optional&
  IDCase () const;

  IDCase_optional&
  IDCase ();

  void
  IDCase (const IDCase_type& x);

  void
  IDCase (const IDCase_optional& x);

  // IDPhase
  //
  typedef ::xml_schema::double_ IDPhase_type;
  typedef ::xsd::cxx::tree::optional< IDPhase_type > IDPhase_optional;
  typedef ::xsd::cxx::tree::traits< IDPhase_type, char, ::xsd::cxx::tree::schema_type::double_ > IDPhase_traits;

  const IDPhase_optional&
  IDPhase () const;

  IDPhase_optional&
  IDPhase ();

  void
  IDPhase (const IDPhase_type& x);

  void
  IDPhase (const IDPhase_optional& x);

  // TypeComposition
  //
  typedef ::xml_schema::string TypeComposition_type;
  typedef ::xsd::cxx::tree::optional< TypeComposition_type > TypeComposition_optional;
  typedef ::xsd::cxx::tree::traits< TypeComposition_type, char > TypeComposition_traits;

  const TypeComposition_optional&
  TypeComposition () const;

  TypeComposition_optional&
  TypeComposition ();

  void
  TypeComposition (const TypeComposition_type& x);

  void
  TypeComposition (const TypeComposition_optional& x);

  void
  TypeComposition (::std::unique_ptr< TypeComposition_type > p);

  // Temperature
  //
  typedef ::xml_schema::double_ Temperature_type;
  typedef ::xsd::cxx::tree::optional< Temperature_type > Temperature_optional;
  typedef ::xsd::cxx::tree::traits< Temperature_type, char, ::xsd::cxx::tree::schema_type::double_ > Temperature_traits;

  const Temperature_optional&
  Temperature () const;

  Temperature_optional&
  Temperature ();

  void
  Temperature (const Temperature_type& x);

  void
  Temperature (const Temperature_optional& x);

  // Value
  //
  typedef ::xml_schema::double_ Value_type;
  typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
  typedef ::xsd::cxx::tree::traits< Value_type, char, ::xsd::cxx::tree::schema_type::double_ > Value_traits;

  const Value_optional&
  Value () const;

  Value_optional&
  Value ();

  void
  Value (const Value_type& x);

  void
  Value (const Value_optional& x);

  // Constructors.
  //
  ScheilCumulativeFractionModel ();

  ScheilCumulativeFractionModel (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  ScheilCumulativeFractionModel (const ScheilCumulativeFractionModel& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual ScheilCumulativeFractionModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ScheilCumulativeFractionModel&
  operator= (const ScheilCumulativeFractionModel& x);

  virtual 
  ~ScheilCumulativeFractionModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDCase_optional IDCase_;
  IDPhase_optional IDPhase_;
  TypeComposition_optional TypeComposition_;
  Temperature_optional Temperature_;
  Value_optional Value_;
};

bool
operator== (const ScheilCumulativeFractionModel&, const ScheilCumulativeFractionModel&);

bool
operator!= (const ScheilCumulativeFractionModel&, const ScheilCumulativeFractionModel&);


class ScheilPhaseFractionModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDCase
  //
  typedef ::xml_schema::int_ IDCase_type;
  typedef ::xsd::cxx::tree::optional< IDCase_type > IDCase_optional;
  typedef ::xsd::cxx::tree::traits< IDCase_type, char > IDCase_traits;

  const IDCase_optional&
  IDCase () const;

  IDCase_optional&
  IDCase ();

  void
  IDCase (const IDCase_type& x);

  void
  IDCase (const IDCase_optional& x);

  // IDPhase
  //
  typedef ::xml_schema::double_ IDPhase_type;
  typedef ::xsd::cxx::tree::optional< IDPhase_type > IDPhase_optional;
  typedef ::xsd::cxx::tree::traits< IDPhase_type, char, ::xsd::cxx::tree::schema_type::double_ > IDPhase_traits;

  const IDPhase_optional&
  IDPhase () const;

  IDPhase_optional&
  IDPhase ();

  void
  IDPhase (const IDPhase_type& x);

  void
  IDPhase (const IDPhase_optional& x);

  // TypeComposition
  //
  typedef ::xml_schema::string TypeComposition_type;
  typedef ::xsd::cxx::tree::optional< TypeComposition_type > TypeComposition_optional;
  typedef ::xsd::cxx::tree::traits< TypeComposition_type, char > TypeComposition_traits;

  const TypeComposition_optional&
  TypeComposition () const;

  TypeComposition_optional&
  TypeComposition ();

  void
  TypeComposition (const TypeComposition_type& x);

  void
  TypeComposition (const TypeComposition_optional& x);

  void
  TypeComposition (::std::unique_ptr< TypeComposition_type > p);

  // Temperature
  //
  typedef ::xml_schema::double_ Temperature_type;
  typedef ::xsd::cxx::tree::optional< Temperature_type > Temperature_optional;
  typedef ::xsd::cxx::tree::traits< Temperature_type, char, ::xsd::cxx::tree::schema_type::double_ > Temperature_traits;

  const Temperature_optional&
  Temperature () const;

  Temperature_optional&
  Temperature ();

  void
  Temperature (const Temperature_type& x);

  void
  Temperature (const Temperature_optional& x);

  // Value
  //
  typedef ::xml_schema::double_ Value_type;
  typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
  typedef ::xsd::cxx::tree::traits< Value_type, char, ::xsd::cxx::tree::schema_type::double_ > Value_traits;

  const Value_optional&
  Value () const;

  Value_optional&
  Value ();

  void
  Value (const Value_type& x);

  void
  Value (const Value_optional& x);

  // Constructors.
  //
  ScheilPhaseFractionModel ();

  ScheilPhaseFractionModel (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  ScheilPhaseFractionModel (const ScheilPhaseFractionModel& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  virtual ScheilPhaseFractionModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ScheilPhaseFractionModel&
  operator= (const ScheilPhaseFractionModel& x);

  virtual 
  ~ScheilPhaseFractionModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDCase_optional IDCase_;
  IDPhase_optional IDPhase_;
  TypeComposition_optional TypeComposition_;
  Temperature_optional Temperature_;
  Value_optional Value_;
};

bool
operator== (const ScheilPhaseFractionModel&, const ScheilPhaseFractionModel&);

bool
operator!= (const ScheilPhaseFractionModel&, const ScheilPhaseFractionModel&);


class SelectedElementsModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDProject
  //
  typedef ::xml_schema::int_ IDProject_type;
  typedef ::xsd::cxx::tree::optional< IDProject_type > IDProject_optional;
  typedef ::xsd::cxx::tree::traits< IDProject_type, char > IDProject_traits;

  const IDProject_optional&
  IDProject () const;

  IDProject_optional&
  IDProject ();

  void
  IDProject (const IDProject_type& x);

  void
  IDProject (const IDProject_optional& x);

  // IDElement
  //
  typedef ::xml_schema::int_ IDElement_type;
  typedef ::xsd::cxx::tree::optional< IDElement_type > IDElement_optional;
  typedef ::xsd::cxx::tree::traits< IDElement_type, char > IDElement_traits;

  const IDElement_optional&
  IDElement () const;

  IDElement_optional&
  IDElement ();

  void
  IDElement (const IDElement_type& x);

  void
  IDElement (const IDElement_optional& x);

  // IsReferenceElement
  //
  typedef ::xml_schema::int_ IsReferenceElement_type;
  typedef ::xsd::cxx::tree::optional< IsReferenceElement_type > IsReferenceElement_optional;
  typedef ::xsd::cxx::tree::traits< IsReferenceElement_type, char > IsReferenceElement_traits;

  const IsReferenceElement_optional&
  IsReferenceElement () const;

  IsReferenceElement_optional&
  IsReferenceElement ();

  void
  IsReferenceElement (const IsReferenceElement_type& x);

  void
  IsReferenceElement (const IsReferenceElement_optional& x);

  // Constructors.
  //
  SelectedElementsModel ();

  SelectedElementsModel (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  SelectedElementsModel (const SelectedElementsModel& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  virtual SelectedElementsModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SelectedElementsModel&
  operator= (const SelectedElementsModel& x);

  virtual 
  ~SelectedElementsModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDProject_optional IDProject_;
  IDElement_optional IDElement_;
  IsReferenceElement_optional IsReferenceElement_;
};

bool
operator== (const SelectedElementsModel&, const SelectedElementsModel&);

bool
operator!= (const SelectedElementsModel&, const SelectedElementsModel&);


class SelectedPhasesModel: public ::xml_schema::type
{
  public:
  // Id
  //
  typedef ::xml_schema::int_ Id_type;
  typedef ::xsd::cxx::tree::optional< Id_type > Id_optional;
  typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

  const Id_optional&
  Id () const;

  Id_optional&
  Id ();

  void
  Id (const Id_type& x);

  void
  Id (const Id_optional& x);

  // IDCase
  //
  typedef ::xml_schema::int_ IDCase_type;
  typedef ::xsd::cxx::tree::optional< IDCase_type > IDCase_optional;
  typedef ::xsd::cxx::tree::traits< IDCase_type, char > IDCase_traits;

  const IDCase_optional&
  IDCase () const;

  IDCase_optional&
  IDCase ();

  void
  IDCase (const IDCase_type& x);

  void
  IDCase (const IDCase_optional& x);

  // IDPhase
  //
  typedef ::xml_schema::int_ IDPhase_type;
  typedef ::xsd::cxx::tree::optional< IDPhase_type > IDPhase_optional;
  typedef ::xsd::cxx::tree::traits< IDPhase_type, char > IDPhase_traits;

  const IDPhase_optional&
  IDPhase () const;

  IDPhase_optional&
  IDPhase ();

  void
  IDPhase (const IDPhase_type& x);

  void
  IDPhase (const IDPhase_optional& x);

  // Constructors.
  //
  SelectedPhasesModel ();

  SelectedPhasesModel (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  SelectedPhasesModel (const SelectedPhasesModel& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual SelectedPhasesModel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SelectedPhasesModel&
  operator= (const SelectedPhasesModel& x);

  virtual 
  ~SelectedPhasesModel ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Id_optional Id_;
  IDCase_optional IDCase_;
  IDPhase_optional IDPhase_;
};

bool
operator== (const SelectedPhasesModel&, const SelectedPhasesModel&);

bool
operator!= (const SelectedPhasesModel&, const SelectedPhasesModel&);


#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, const ActivePhasesModel&);

::std::ostream&
operator<< (::std::ostream&, const ActivePhasesConfigurationModel&);

::std::ostream&
operator<< (::std::ostream&, const ActivePhasesElementCompositionModel&);

::std::ostream&
operator<< (::std::ostream&, const CALPHADDatabaseModel&);

::std::ostream&
operator<< (::std::ostream&, const CaseModel&);

::std::ostream&
operator<< (::std::ostream&, const ElementModel&);

::std::ostream&
operator<< (::std::ostream&, const ElementCompositionModel&);

::std::ostream&
operator<< (::std::ostream&, const EquilibriumConfigurationModel&);

::std::ostream&
operator<< (::std::ostream&, const EquilibriumPhaseFractionModel&);

::std::ostream&
operator<< (::std::ostream&, const HeatTreatmentModel&);

::std::ostream&
operator<< (::std::ostream&, const HeatTreatmentProfileModel&);

::std::ostream&
operator<< (::std::ostream&, const HeatTreatmentSegmentModel&);

::std::ostream&
operator<< (::std::ostream&, const PhaseModel&);

::std::ostream&
operator<< (::std::ostream&, const PrecipitationSimulationDataModel&);

::std::ostream&
operator<< (::std::ostream&, const PrecipitationDomainModel&);

::std::ostream&
operator<< (::std::ostream&, const PrecipitationPhaseModel&);

::std::ostream&
operator<< (::std::ostream&, const ProjectModel&);

::std::ostream&
operator<< (::std::ostream&, const ScheilConfigurationModel&);

::std::ostream&
operator<< (::std::ostream&, const ScheilCumulativeFractionModel&);

::std::ostream&
operator<< (::std::ostream&, const ScheilPhaseFractionModel&);

::std::ostream&
operator<< (::std::ostream&, const SelectedElementsModel&);

::std::ostream&
operator<< (::std::ostream&, const SelectedPhasesModel&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const ActivePhasesModel&);

void
operator<< (::xercesc::DOMElement&, const ActivePhasesConfigurationModel&);

void
operator<< (::xercesc::DOMElement&, const ActivePhasesElementCompositionModel&);

void
operator<< (::xercesc::DOMElement&, const CALPHADDatabaseModel&);

void
operator<< (::xercesc::DOMElement&, const CaseModel&);

void
operator<< (::xercesc::DOMElement&, const ElementModel&);

void
operator<< (::xercesc::DOMElement&, const ElementCompositionModel&);

void
operator<< (::xercesc::DOMElement&, const EquilibriumConfigurationModel&);

void
operator<< (::xercesc::DOMElement&, const EquilibriumPhaseFractionModel&);

void
operator<< (::xercesc::DOMElement&, const HeatTreatmentModel&);

void
operator<< (::xercesc::DOMElement&, const HeatTreatmentProfileModel&);

void
operator<< (::xercesc::DOMElement&, const HeatTreatmentSegmentModel&);

void
operator<< (::xercesc::DOMElement&, const PhaseModel&);

void
operator<< (::xercesc::DOMElement&, const PrecipitationSimulationDataModel&);

void
operator<< (::xercesc::DOMElement&, const PrecipitationDomainModel&);

void
operator<< (::xercesc::DOMElement&, const PrecipitationPhaseModel&);

void
operator<< (::xercesc::DOMElement&, const ProjectModel&);

void
operator<< (::xercesc::DOMElement&, const ScheilConfigurationModel&);

void
operator<< (::xercesc::DOMElement&, const ScheilCumulativeFractionModel&);

void
operator<< (::xercesc::DOMElement&, const ScheilPhaseFractionModel&);

void
operator<< (::xercesc::DOMElement&, const SelectedElementsModel&);

void
operator<< (::xercesc::DOMElement&, const SelectedPhasesModel&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif //
